[
  {
    "operation": "acceleration_ratio_long",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].pct_change(periods=20).iloc[-1]) / ({t}_ohlcv_15m_df['close'].pct_change(periods=60).iloc[-1] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "acceleration_ratio_medium",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].pct_change(periods=5).iloc[-1]) / ({t}_ohlcv_15m_df['close'].pct_change(periods=20).iloc[-1] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "active_addresses_24h",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m  Active Addresses 24h (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment)",
    "transform": "parse 'value' to 'active_addresses_24h' df column. All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_active_addresses_24h_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  active_addresses_24h",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "adaptive_bollinger_breakout_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_15m_df {t}_atr_15m_df {t}_ohlcv_15m_df",
    "transform": "bb_upper = {t}_bbands_15m_df['bb_upper']; bb_lower = {t}_bbands_15m_df['bb_lower']; bb_middle = {t}_bbands_15m_df['bb_middle']; price = {t}_ohlcv_15m_df['close']; volatility = {t}_atr_15m_df['average_true_range'] / price; vol_adjustment = volatility.rolling(20).rank(pct=True); adaptive_upper = bb_upper + (bb_upper - bb_middle) * vol_adjustment; adaptive_lower = bb_lower - (bb_middle - bb_lower) * vol_adjustment; breakout_signal = np.where(price > adaptive_upper, 1, np.where(price < adaptive_lower, -1, 0)); adaptive_breakout = breakout_signal * abs(price.pct_change()) * (volatility.rolling(20).rank(pct=True)); adaptive_breakout",
    "output_data_type": "float64",
    "output_data_unit": "breakout_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "adaptive_momentum_threshold_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df {t}_rsi_15m_df",
    "transform": "returns = {t}_ohlcv_15m_df['close'].pct_change(); volatility = {t}_atr_15m_df['average_true_range'] / {t}_ohlcv_15m_df['close']; rsi = {t}_rsi_15m_df['rsi']; vol_regime = volatility.rolling(50).rank(pct=True); adaptive_threshold = 0.5 + 0.3 * vol_regime; momentum_signal = np.where(rsi > (50 + adaptive_threshold * 30), 1, np.where(rsi < (50 - adaptive_threshold * 30), -1, 0)); adaptive_momentum = momentum_signal * abs(returns); adaptive_momentum",
    "output_data_type": "float64",
    "output_data_unit": "adaptive_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "adx_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=30) adjustable settings to be added to config.py (defaults: Period=30)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_adx_15m_df",
    "df_storage_period": 51,
    "df_keys": "timestamp  adx",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=30) adjustable settings to be added to config.py (defaults: Period=30) Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_adx_1d_df",
    "df_storage_period": 51,
    "df_keys": "timestamp  adx",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=30) adjustable settings to be added to config.py (defaults: Period=30) Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_adx_1h_df",
    "df_storage_period": 51,
    "df_keys": "timestamp  adx",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=40) adjustable settings to be added to config.py (defaults: Period=40) Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_adx_4h_df",
    "df_storage_period": 51,
    "df_keys": "timestamp  adx",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_di_signal_strength_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_1d_df {t}_di_1d_df",
    "transform": "adx = {t}_adx_1d_df['adx']; plus_di_opt = {t}_di_1d_df['adx_pos']; minus_di_opt = {t}_di_1d_df['adx_neg']; di_spread = plus_di_opt - minus_di_opt; di_crossover_signal = np.where((plus_di_opt > minus_di_opt) & (plus_di_opt.shift(1) <= minus_di_opt.shift(1))  1  np.where((plus_di_opt < minus_di_opt) & (plus_di_opt.shift(1) >= minus_di_opt.shift(1))  -1  0)); adx_momentum = adx.pct_change(3) * 100; (0.4 * np.tanh(adx/50) + 0.3 * np.tanh(abs(di_spread)/20) + 0.2 * di_crossover_signal + 0.1 * np.tanh(adx_momentum/10))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionelss score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_di_signal_strength_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_4h_df {t}_di_4h_df",
    "transform": "adx = {t}_adx_4h_df['adx']; plus_di_opt = {t}_di_4h_df['adx_pos']; minus_di_opt = {t}_di_4h_df['adx_neg']; di_spread = plus_di_opt - minus_di_opt; di_crossover_signal = np.where((plus_di_opt > minus_di_opt) & (plus_di_opt.shift(1) <= minus_di_opt.shift(1))  1  np.where((plus_di_opt < minus_di_opt) & (plus_di_opt.shift(1) >= minus_di_opt.shift(1))  -1  0)); adx_momentum = adx.pct_change(3) * 100; (0.4 * np.tanh(adx/50) + 0.3 * np.tanh(abs(di_spread)/20) + 0.2 * di_crossover_signal + 0.1 * np.tanh(adx_momentum/10))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionelss score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_percentile_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_15m_df",
    "transform": "{t}_adx_15m_df['adx'].rolling(50).rank(pct=True)",
    "output_data_type": "float64",
    "output_data_unit": "dimesnionless percentile",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_percentile_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_1d_df",
    "transform": "{t}_adx_1d_df['adx'].rolling(50).rank(pct=True)",
    "output_data_type": "float64",
    "output_data_unit": "dimesnionless percentile",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_percentile_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_1h_df",
    "transform": "{t}_adx_1h_df['adx'].rolling(50).rank(pct=True)",
    "output_data_type": "float64",
    "output_data_unit": "dimesnionless percentile",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "adx_percentile_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_4h_df",
    "transform": "{t}_adx_4h_df['adx'].rolling(50).rank(pct=True)",
    "output_data_type": "float64",
    "output_data_unit": "dimesnionless percentile",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "agg_open_interest_chg_pct_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df",
    "transform": "df['oi_total_15m'].pct_change(periods=16).iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "amihud_illiquidty_zscore_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))(mlfinlab.get_amihud_illiquidity({t}_ohlcv_15m_df['close'] * {t}_ohlcv_15m_df['volume']  window=20))",
    "output_data_type": "float64",
    "output_data_unit": "ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.volatility.AverageTrueRange(high  low  close  window=40).average_true_range() adjustable settings to be added to config.py (defaults: Period=40  MA Type = RMA)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_atr_15m_df",
    "df_storage_period": 2880,
    "df_keys": "timestamp  average_true_range",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.volatility.AverageTrueRange(high  low  close  window=40).average_true_range() adjustable settings to be added to config.py (defaults: Period=40 MA Type = RMA) Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_atr_1d_df",
    "df_storage_period": 730,
    "df_keys": "timestamp  average_true_range",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.volatility.AverageTrueRange(high  low  close  window=40).average_true_range() adjustable settings to be added to config.py (defaults: Period=40 MA Type = RMA). ",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_atr_1h_df",
    "df_storage_period": 1440,
    "df_keys": "timestamp  average_true_range",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_3pct_ratio_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_15m_df {t}_ohlcv_15m_df",
    "transform": "3.0 / (({t}_atr_15m_df['average_true_range'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100) + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_3pct_ratio_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1d_df {t}_ohlcv_1d_df",
    "transform": "3.0 / (({t}_atr_1d_df['average_true_range'] / ({t}_ohlcv_1d_df['close'] + 1e-9) * 100) + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_3pct_ratio_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1h_df {t}_ohlcv_1h_df",
    "transform": "3.0 / (({t}_atr_1h_df['average_true_range'] / ({t}_ohlcv_1h_df['close'] + 1e-9) * 100) + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_3pct_ratio_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_4h_df {t}_ohlcv_4h_df",
    "transform": "3.0 / (({t}_atr_4h_df['average_true_range'] / ({t}_ohlcv_4h_df['close'] + 1e-9) * 100) + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.volatility.AverageTrueRange(high  low  close  window=14).average_true_range() adjustable settings to be added to config.py (defaults: Period=40 MA Type = RMA) Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_atr_4h_df",
    "df_storage_period": 1080,
    "df_keys": "timestamp  average_true_range",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_directional_strength_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1d_df {t}_ohlcv_1d_df",
    "transform": "atr_directional_strength = abs({t}_ohlcv_1d_df['close'].diff(1)) / ({t}_atr_1d_df['average_true_range'] + 1e-9); (lambda s: (s - s.rolling(window=20).mean()) / (s.rolling(window=20).std() + 1e-9))(atr_directional_strength)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_intraday_ratio_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1h_df",
    "transform": "atr_daily_avg = {t}_atr_1h_df['average_true_range'].resample('D').mean().reindex({t}_atr_1h_df.index  method='ffill'); {t}_atr_1h_df['average_true_range'] / (atr_daily_avg + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_mean_reversion_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_4h_df",
    "transform": "atr_zscore = ({t}_atr_4h_df['average_true_range'] - {t}_atr_4h_df['average_true_range'].rolling(window=50).mean()) / ({t}_atr_4h_df['average_true_range'].rolling(window=50).std() + 1e-9); np.where(atr_zscore > 2.0  -1  np.where(atr_zscore > 1.5  -0.5  np.where(atr_zscore < -2.0  1  np.where(atr_zscore < -1.5  0.5  0))))",
    "output_data_type": "float64",
    "output_data_unit": "graded signal",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_normalized_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_15m_df {t}_ohlcv_15m_df",
    "transform": "{t}_atr_15m_df['average_true_range'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_atr_normalized_15m_df",
    "df_storage_period": 5,
    "df_keys": "timestamp atr_normalized",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_normalized_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1d_df {t}_ohlcv_1d_df",
    "transform": "{t}_atr_1d_df['average_true_range'] / ({t}_ohlcv_1d_df['close'] + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_normalized_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1h_df {t}_ohlcv_1h_df",
    "transform": "{t}_atr_1h_df['average_true_range'] / ({t}_ohlcv_1h_df['close'] + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_normalized_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_4h_df {t}_ohlcv_4h_df",
    "transform": "{t}_atr_4h_df['average_true_range'] / ({t}_ohlcv_4h_df['close'] + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_regime_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_1d_df",
    "transform": "{t}_atr_1d_df['average_true_range'] / ({t}_atr_1d_df['average_true_range'].rolling(20).mean() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_regime_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_4h_df",
    "transform": "{t}_atr_4h_df['average_true_range'] / ({t}_atr_4h_df['average_true_range'].rolling(20).mean() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_target_feasibility_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_15m_df {t}_ohlcv_15m_df",
    "transform": "np.where(({t}_atr_15m_df['average_true_range'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100) >= 4.0  5.0  np.where(({t}_atr_15m_df['average_true_range'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100) >= 3.0  4.0  np.where(({t}_atr_15m_df['average_true_range'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100) >= 2.0  3.0  np.where(({t}_atr_15m_df['average_true_range'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100) >= 1.0  2.0  1.0))))",
    "output_data_type": "float64",
    "output_data_unit": "categorical score",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "atr_target_probability_2pct_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df {t}_atr_4h_df",
    "transform": "({t}_atr_4h_df['average_true_range'] >= ({t}_ohlcv_4h_df['close'] * 0.02)).rolling(window=180).mean()",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "atr_trend_strength_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_normalized_15m_df, {t}_trend_strength_15m_df",
    "transform": "{t}_atr_normalized_15m_df['atr_normalized'] * abs({t}_trend_strength_15m_df['trend_strength'])",
    "output_data_type": "float64",
    "output_data_unit": "trend_volatility_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "avwap_slope_5d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_vwap_1d_df ",
    "transform": "(df['volume_weighted_average_price'].iloc[-1] - df['volume_weighted_average_price'].iloc[-6]) / (5 * df['volume_weighted_average_price'].iloc[-6])",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "barrier_bear",
    "live_cadence": "training only",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "for each candle in the historical 15m OHCLV dataset calculate ['close'] - (ta.volatility.AverageTrueRange* 1.25)  adjustable settings to be added to config.py (ATR defaults: Period=14 MA Type = RMA). Save values to {t}_barrier_bear_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_bear_df",
    "df_storage_period": 1051200,
    "df_keys": "timestamp barrier_bear",
    "df_frame_store": false,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_bear_invalid",
    "live_cadence": "training only",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "for each candle in the historical 15m OHCLV dataset calculate ['close'] + (ta.volatility.AverageTrueRange* 0.75)  adjustable settings to be added to config.py (ATR defaults: Period=14 MA Type = RMA). Save values to {t}_barrier_bear_invalid_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_bear_invalid_df",
    "df_storage_period": 1051200,
    "df_keys": "timestamp barrier_bear_invalid",
    "df_frame_store": false,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_bull",
    "live_cadence": "training only",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "for each candle in the historical 15m OHCLV dataset calculate ['close'] + (ta.volatility.AverageTrueRange* 1.25)  adjustable settings to be added to config.py (ATR defaults: Period=14 MA Type = RMA). Save values to {t}_barrier_bull_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_bull_df",
    "df_storage_period": 1051200,
    "df_keys": "timestamp barrier_bull",
    "df_frame_store": false,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_bull_invalid",
    "live_cadence": "training only",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "for each candle in the historical 15m OHCLV dataset calculate ['close'] - (ta.volatility.AverageTrueRange* 0.75)  adjustable settings to be added to config.py (ATR defaults: Period=14 MA Type = RMA). Save values to {t}_barrier_bull_invalid_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_bull_invalid_df",
    "df_storage_period": 1051200,
    "df_keys": "timestamp barrier_bull_invalid",
    "df_frame_store": false,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_pct_bear",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "(({t}_atr_15m_df['average_true_range']*-1.25)/{t}_ohlcv_15m_df['close']*100 adjustable settings to be added to config.py (defaults: ATR Multiplier=-1.25)  this transform is only used to store a value for our logic engine",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_pct_bear_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  barrier_pct_bear",
    "df_frame_store": true,
    "df_update_mode": "overwirte",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_pct_bear_invalid",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "(({t}_atr_15m_df['average_true_range']*-0.75)/{t}_ohlcv_15m_df['close']*100 adjustable settings to be added to config.py (defaults: ATR Multiplier=-0.75)  this transform is only used to store a value for our logic engine",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_pct_bear_invalid_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  barrier_pct_bear_invalid",
    "df_frame_store": true,
    "df_update_mode": "overwirte",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_pct_bull",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "(({t}_atr_15m_df['average_true_range']*1.25)/{t}_ohlcv_15m_df['close']*100 adjustable settings to be added to config.py (defaults: ATR Multiplier=1.25)  this transform is only used to store a value for our logic engine",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_pct_bull_df",
    "df_storage_period": 1,
    "df_keys": "timestamp barrier_pct_bull",
    "df_frame_store": true,
    "df_update_mode": "overwirte",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_pct_bull_invalid",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "(({t}_atr_15m_df['average_true_range']*0.75)/{t}_ohlcv_15m_df['close']*100 adjustable settings to be added to config.py (defaults: ATR Multiplier=0.75)  this transform is only used to store a value for our logic engine",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_pct_bull_invalid_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  barrier_pct_bull_invalid",
    "df_frame_store": true,
    "df_update_mode": "overwirte",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_pct_strong_bear",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "(({t}_atr_15m_df['average_true_range']*-2.5)/{t}_ohlcv_15m_df['close']*100 adjustable settings to be added to config.py (defaults: ATR Multiplier=-2.5)  this transform is only used to store a value for our logic engine",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_pct_strong_bear_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  barrier_pct_strong_bear",
    "df_frame_store": true,
    "df_update_mode": "overwirte",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_pct_strong_bull",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "(({t}_atr_15m_df['average_true_range']*2.5)/{t}_ohlcv_15m_df['close']*100 adjustable settings to be added to config.py (defaults: ATR Multiplier=2.5) this transform is only used to store a value for our logic engine",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_pct_strong_bull_df",
    "df_storage_period": 1,
    "df_keys": "timestamp barrier_pct_strong_bull",
    "df_frame_store": true,
    "df_update_mode": "overwirte",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_strong_bear",
    "live_cadence": "training only",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "for each candle in the historical 15m OHCLV dataset calculate ['close'] - (ta.volatility.AverageTrueRange* 2.5)  adjustable settings to be added to config.py (ATR defaults: Period=14 MA Type = RMA). Save values to {t}_barrier_strong_bear_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_strong_bear_df",
    "df_storage_period": 1051200,
    "df_keys": "timestamp barrier_strong_bear",
    "df_frame_store": false,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "barrier_strong_bull",
    "live_cadence": "training only",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "for each candle in the historical 15m OHCLV dataset calculate ['close'] + (ta.volatility.AverageTrueRange* 2.5)  adjustable settings to be added to config.py (ATR defaults: Period=14 MA Type = RMA). Save values to {t}_barrier_strong_bull_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_barrier_strong_bull_df",
    "df_storage_period": 1051200,
    "df_keys": "timestamp barrier_bull_strong",
    "df_frame_store": false,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "bars_since_fvg_created_bear_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_15m_df[{t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bearish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bear_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1d_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_1d_df[{t}_smc_fvg_1d_df['smc_fvg_direction'] == 'bearish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bear_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_1h_df[{t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bearish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bear_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_4h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_4h_df[{t}_smc_fvg_4h_df['smc_fvg_direction'] == 'bearish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bull_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_15m_df[{t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bullish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bull_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1d_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_1d_df[{t}_smc_fvg_1d_df['smc_fvg_direction'] == 'bullish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bull_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_1h_df[{t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bullish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_fvg_created_bull_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_4h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_fvg_4h_df[{t}_smc_fvg_4h_df['smc_fvg_direction'] == 'bullish'].iloc[-1]['smc_fvg_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_high_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_15m_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_high_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_high_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_high_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_kz_start",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. resets to zero when new kill zone window begins",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_low_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_15m_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_low_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_low_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_low_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low'].iloc[-1]['smc_swing_confirmation_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_midnight_utc",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. resets to zero at start of each UTC day",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ms_event_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_15m_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_event_15m_df.iloc[-1]['smc_event_break_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ms_event_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_1d_df  ",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_event_1d_df.iloc[-1]['smc_event_break_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ms_event_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_event_1h_df.iloc[-1]['smc_event_break_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ms_event_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_4h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_event_4h_df.iloc[-1]['smc_event_break_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bear_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_15m_df[{t}_smc_ob_15m_df['smc_ob_direction'] == 'bearish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bear_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1d_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_1d_df[{t}_smc_ob_1d_df['smc_ob_direction'] == 'bearish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bear_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_1h_df[{t}_smc_ob_1h_df['smc_ob_direction'] == 'bearish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bear_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_4h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_4h_df[{t}_smc_ob_4h_df['smc_ob_direction'] == 'bearish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bull_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_15m_df[{t}_smc_ob_15m_df['smc_ob_direction'] == 'bullish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bull_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1d_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_1d_df[{t}_smc_ob_1d_df['smc_ob_direction'] == 'bullish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bull_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_1h_df[{t}_smc_ob_1h_df['smc_ob_direction'] == 'bullish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_created_bull_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_4h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_4h_df[{t}_smc_ob_4h_df['smc_ob_direction'] == 'bullish'].iloc[-1]['smc_ob_created_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_mitig_bear_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'mitigated')].iloc[-1]['smc_ob_mitigated_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_mitig_bear_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'mitigated')].iloc[-1]['smc_ob_mitigated_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_mitig_bull_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'mitigated')].iloc[-1]['smc_ob_mitigated_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_ob_mitig_bull_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df",
    "transform": "(pd.Timestamp.now(tz='UTC') - pd.to_datetime({t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'mitigated')].iloc[-1]['smc_ob_mitigated_time'])).total_seconds() / (60 * 15)",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_since_session_open",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. resets to zero when session window switches Asia London New York",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_to_kz_end",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. resets to zero when kill zone window ends",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bars_to_session_close",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. resets to zero at start of next session window",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "basis_flip_up",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_basis_pct_15m_df",
    "transform": "(({t}_basis_pct_15m_df['basis_pct_15m'].shift(1) < 0) & ({t}_basis_pct_15m_df['basis_pct_15m'] > 0)).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "basis_momentum",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_basis_pct_15m_df",
    "transform": "{t}_basis_pct_15m_df['basis_pct_15m'].pct_change(periods=1)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "basis_pct",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m{t}_futures_mark_price_15m_df {t}_basis_pct_15m_df",
    "transform": "({t}_futures_mark_price_15m_df['last'] - {t}_ohlcv_15m['close']) /{t}_ohlcv_15m['close']  parse result to {t}_basis_pct_15m_df dataframe",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_basis_pct_15m_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  basis_pct_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.volatility.BollingerBands(close  window=60  window_dev=1.5) adjustable settings to be added to config.py (defaults: Period=60 Std Dev=1.5)",
    "output_data_type": "float64",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_bbands_15m_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  bollinger_mavg bollinger_hband bollinger_lband bollinger_pband bollinger_wband",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.volatility.BollingerBands(close  window=60  window_dev=1.5) adjustable settings to be added to config.py (defaults: Period=60 Std Dev=1.5)",
    "output_data_type": "float64",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_bbands_1d_df",
    "df_storage_period": 21,
    "df_keys": "timestamp  bollinger_mavg bollinger_hband bollinger_lband bollinger_pband bollinger_wband",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.volatility.BollingerBands(close  window=60  window_dev=1.5) adjustable settings to be added to config.py (defaults: Period=60 Std Dev=1.5)",
    "output_data_type": "float64",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_bbands_1h_df",
    "df_storage_period": 21,
    "df_keys": "timestamp  bollinger_mavg bollinger_hband bollinger_lband bollinger_pband bollinger_wband",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.volatility.BollingerBands(close  window=60  window_dev=1.5) adjustable settings to be added to config.py (defaults: Period=60 Std Dev=1.5)",
    "output_data_type": "float64",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_bbands_4h_df",
    "df_storage_period": 21,
    "df_keys": "timestamp  bollinger_mavg bollinger_hband bollinger_lband bollinger_pband bollinger_wband",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_breakout_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_4h_df",
    "transform": "current_width = {t}_bbands_4h_df['bollinger_wband']; width_ratio = current_width / (current_width.rolling(window=20).mean() + 1e-9); width_percentile = current_width.rolling(window=50).rank(pct=True); np.where((width_ratio < 0.7) & (width_percentile < 0.2)  1.0  np.where((width_ratio < 0.8) & (width_percentile < 0.3)  0.7  np.where(width_ratio < 0.9  0.4  np.where(width_ratio > 1.3  -0.3  0))))",
    "output_data_type": "float64",
    "output_data_unit": "graded signal",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_mean_reversion_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df {t}_bbands_1d_df",
    "transform": "band_position = {t}_bbands_1d_df['bollinger_pband']; distance_from_middle = abs({t}_ohlcv_1d_df['close'] - {t}_bbands_1d_df['bollinger_mavg']) / {t}_bbands_1d_df['bollinger_mavg'] * 100; np.where((band_position > 0.95) & (distance_from_middle > 2)  -1.0  np.where((band_position > 0.85) & (distance_from_middle > 1.5)  -0.5  np.where((band_position < 0.05) & (distance_from_middle > 2)  1.0  np.where((band_position < 0.15) & (distance_from_middle > 1.5)  0.5  0))))",
    "output_data_type": "float64",
    "output_data_unit": "graded signal",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_pos_norm_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_15m_df",
    "transform": "{t}_bbands_15m_df['bollinger_pband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_pos_norm_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1d_df",
    "transform": "{t}_bbands_1d_df['bollinger_pband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_pos_norm_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1h_df",
    "transform": "{t}_bbands_1h_df['bollinger_pband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_pos_norm_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_4h_df",
    "transform": "{t}_bbands_4h_df['bollinger_pband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_squeeze_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1d_df",
    "transform": "{t}_bbands_1d_df['bollinger_wband'] / ({t}_bbands_1d_df['bollinger_wband'].rolling(20).mean() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_squeeze_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1h_df",
    "transform": "{t}_bbands_1h_df['bollinger_wband'] / ({t}_bbands_1h_df['bollinger_wband'].rolling(20).mean() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_squeeze_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_4h_df",
    "transform": "{t}_bbands_4h_df['bollinger_wband'] / ({t}_bbands_4h_df['bollinger_wband'].rolling(20).mean() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_strength_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1d_df",
    "transform": "abs({t}_bbands_1d_df['bollinger_mavg'].pct_change(5)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_strength_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_4h_df",
    "transform": "abs({t}_bbands_4h_df['bollinger_mavg'].pct_change(5)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_width_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_15m_df",
    "transform": "{t}_bbands_15m_df['bollinger_wband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_width_pct_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1d_df",
    "transform": "{t}_bbands_1d_df['bollinger_wband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_width_pct_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_1h_df",
    "transform": "{t}_bbands_1h_df['bollinger_wband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bbands_width_pct_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_bbands_4h_df",
    "transform": "{t}_bbands_4h_df['bollinger_wband']",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bear_run_len_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda s: (s.groupby((s != s.shift()).cumsum()).cumsum() * s).iloc[-1])({t}_ohlcv_15m_df['close'] < {t}_ohlcv_15m_df['open'])",
    "output_data_type": "int32",
    "output_data_unit": "bars",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bear_run_len_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "(lambda s: (s.groupby((s != s.shift()).cumsum()).cumsum() * s).iloc[-1])({t}_ohlcv_1h_df['close'] < {t}_ohlcv_1h_df['open'])",
    "output_data_type": "int32",
    "output_data_unit": "bars",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bearish_alignment_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df {t}_ema_slow_1d_df",
    "transform": "(({t}_ema_fast_1d_df['ema_indicator'] < {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_mid_1d_df['ema_indicator'] < {t}_ema_slow_1d_df['ema_indicator'])).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bearish_alignment_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1h_df {t}_ema_mid_1h_df {t}_ema_slow_1h_df",
    "transform": "(({t}_ema_fast_1h_df['ema_indicator'] < {t}_ema_mid_1h_df['ema_indicator']) & ({t}_ema_mid_1h_df['ema_indicator'] < {t}_ema_slow_1h_df['ema_indicator'])).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bearish_alignment_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_4h_df {t}_ema_mid_4h_df {t}_ema_slow_4h_df",
    "transform": "(({t}_ema_fast_4h_df['ema_indicator'] < {t}_ema_mid_4h_df['ema_indicator']) & ({t}_ema_mid_4h_df['ema_indicator'] < {t}_ema_slow_4h_df['ema_indicator'])).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "behavioral_herding_indicator_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_social_dominance_total_15m_df {t}_sentiment_weighted_total_15m_df",
    "transform": "price_momentum = {t}_ohlcv_15m_df['close'].pct_change(20); social_momentum = {t}_social_dominance_total_15m_df['social_dominance'].pct_change(20); sentiment_momentum = {t}_sentiment_weighted_total_15m_df['sentiment_weighted'].pct_change(20); herding_score = (price_momentum * social_momentum * sentiment_momentum).rolling(20).mean() / (abs(price_momentum).rolling(20).mean() + 1e-9); herding_score",
    "output_data_type": "float64",
    "output_data_unit": "herding_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "beta_vs_total2_30d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "btc_mcap_1d_df {t}_ohlcv_1d_df total_mcap_close_1d_df",
    "transform": "( (np.log({t}_ohlcv_1d_df['close'] / ({t}_ohlcv_1d_df['close'].shift + 1e-9)(1))).rolling(window=30).cov(np.log((total_mcap_close_1d_df['total_market_cap_1d'] - btc_mcap_1d_df['btc_mcap_1d']) / (total_mcap_close_1d_df['total_market_cap_1d'] - btc_mcap_1d_df['btc_mcap_1d']).shift(1))) / (np.log((total_mcap_close_1d_df['total_market_cap_1d'] - btc_mcap_1d_df['btc_mcap_1d']) / (total_mcap_close_1d_df['total_market_cap_1d'] - btc_mcap_1d_df['btc_mcap_1d']).shift(1))).rolling(window=30).var() ).iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "body_ratio_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(abs({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_ohlcv_15m_df['open'].iloc[-1]) / ({t}_ohlcv_15m_df['high'].iloc[-1] - {t}_ohlcv_15m_df['low'].iloc[-1] + 1e-6)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "breakdown_strength_volume_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].pct_change(1) * ({t}_ohlcv_15m_df['volume'] / ({t}_ohlcv_15m_df['volume'].rolling + 1e-9)(window=20).mean())).where({t}_ohlcv_15m_df['close'] < {t}_ohlcv_15m_df['low'].rolling(window=20).min().shift(1), 0)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "breakout_strength_volume_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].pct_change(1) * ({t}_ohlcv_15m_df['volume'] / ({t}_ohlcv_15m_df['volume'].rolling + 1e-9)(window=20).mean())).where({t}_ohlcv_15m_df['close'] > {t}_ohlcv_15m_df['high'].rolling(window=20).max().shift(1), 0)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "btc_etf_flow_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d ETF Flow for BTC (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'btc_etf_flow_1d' df column. All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "btc_etf_flow_1d_df",
    "df_storage_period": 7,
    "df_keys": "timestamp  btc_etf_flow_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "btc_etf_flow_zscore_5d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "btc_etf_flow_1d_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)(btc_etf_flow_1d_df['btc_etf_flow_1d'].iloc[-5:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "btc_funding_rate_zscore_7d",
    "live_cadence": "30m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "btc_funding_rate_30m_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)(btc_funding_rate_30_df['last'].iloc[-336:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "btc_mcap_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d BTC Market Cap from Cryptocurrency Quotes Historical v2 (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap) ",
    "transform": "parse 'market_cap' to 'btc_mcap_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "btc_mcap_1d_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  btc_mcap_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "btc_option_oi_pct_change_24h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "btc_oi_total_15m_df",
    "transform": "btc_oi_total_15m_df['oi_total_15m'].pct_change(periods=96).iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "btc_perp_basis_1w_pct",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "btc_futures_data_15m_df btc_ohlcv_15m_df",
    "transform": "(((btc_futures_mark_price_15m_df['last'] - btc_ohlcv_15m_df['close']) / btc_ohlcv_15m_df['close']).rolling(window=672).mean().iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "btc_perp_close_7d",
    "live_cadence": "7d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live: 7d  Futures OHLCV (Refer to Unicorn_Wealth_API_Reference Guide: 1.0 CoinAPI) ",
    "transform": "parse 'price_close' to 'btc_perpClose_7d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "btc_perp_close_7d_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  btc_perpClose_7d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "btc_supply_usd_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d BTC Circulating Supply from Cryptocurrency Quotes Historical v2 (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap) ",
    "transform": "parse 'circulating_supply' to 'btc_supply_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "btc_circ_supply_1d_df",
    "df_storage_period": 11,
    "df_keys": "timestamp  btc_supply_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "btcd_close_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d BTC Dominance from Global Metrics Quotes Historical (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap) ",
    "transform": "parse 'btc_dominance' to'btc_dominance' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "btcd_close_1d_df",
    "df_storage_period": 20,
    "df_keys": "timestamp  btc_dominance",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "btcd_dist_to_ma20_pct_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "btcd_close_1d_df",
    "transform": "(lambda s: 100 * (s.iloc[-1] - s.mean()) / s.mean())(btcd_close_1d_df['btc_dominance'].iloc[-20:])",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bull_run_len_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda s: (s.groupby((s != s.shift()).cumsum()).cumsum() * s).iloc[-1])({t}_ohlcv_15m_df['close'] > {t}_ohlcv_15m_df['open'])",
    "output_data_type": "int32",
    "output_data_unit": "bars",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bull_run_len_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "(lambda s: (s.groupby((s != s.shift()).cumsum()).cumsum() * s).iloc[-1])({t}_ohlcv_1h_df['close'] > {t}_ohlcv_1h_df['open'])",
    "output_data_type": "int32",
    "output_data_unit": "bars",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bullish_alignment_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df {t}_ema_slow_1d_df",
    "transform": "(({t}_ema_fast_1d_df['ema_indicator'] > {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_mid_1d_df['ema_indicator'] > {t}_ema_slow_1d_df['ema_indicator'])).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bullish_alignment_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1h_df {t}_ema_mid_1h_df {t}_ema_slow_1h_df",
    "transform": "(({t}_ema_fast_1h_df['ema_indicator'] > {t}_ema_mid_1h_df['ema_indicator']) & ({t}_ema_mid_1h_df['ema_indicator'] > {t}_ema_slow_1h_df['ema_indicator'])).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "bullish_alignment_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_4h_df {t}_ema_mid_4h_df {t}_ema_slow_4h_df",
    "transform": "(({t}_ema_fast_4h_df['ema_indicator'] > {t}_ema_mid_4h_df['ema_indicator']) & ({t}_ema_mid_4h_df['ema_indicator'] > {t}_ema_slow_4h_df['ema_indicator'])).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "burn_rate_pct_supply_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_supply_usd_15m_df fees_burnt_usd_df",
    "transform": "100 * fees_burnt_usd_df['fees_burnt_usd_15m'].iloc[-1] / (eth_supply_usd_15m_df['eth_supply_15m'].iloc[-1] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "candle_patterns_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "Use TA-Lib candlestick pattern functions (CDL*) on the OHLCV data in {t}_ohlcv_15m_df. For each row, call all pattern functions and record the result values (integer outputs). Identify the active pattern by selecting the non-zero result if one exists.Identify if the pattern is a bullish or bearish variant if applicable.  Pass the detected candlestick pattern name as a string (e.g., \"Hammer\", \"Doji\", \"Engulfing Bullish\", \"No Pattern\" if all results are zero). If a single candle pattern and multi candle pattern present at the same time, then the multi candle pattern should always take priority. ",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "candle_patterns_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "Use TA-Lib candlestick pattern functions (CDL*) on the OHLCV data in {t}_ohlcv_1d_df. For each row, call all pattern functions and record the result values (integer outputs). Identify the active pattern by selecting the non-zero result if one exists.Identify if the pattern is a bullish or bearish variant if applicable.  Pass the detected candlestick pattern name as a string (e.g., \"Hammer\", \"Doji\", \"Engulfing Bullish\", \"No Pattern\" if all results are zero). If a single candle pattern and multi candle pattern present at the same time, then the multi candle pattern should always take priority. ",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "candle_patterns_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "Use TA-Lib candlestick pattern functions (CDL*) on the OHLCV data in {t}_ohlcv_1h_df. For each row, call all pattern functions and record the result values (integer outputs). Identify the active pattern by selecting the non-zero result if one exists.Identify if the pattern is a bullish or bearish variant if applicable.  Pass the detected candlestick pattern name as a string (e.g., \"Hammer\", \"Doji\", \"Engulfing Bullish\", \"No Pattern\" if all results are zero). If a single candle pattern and multi candle pattern present at the same time, then the multi candle pattern should always take priority. ",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "candle_patterns_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "Use TA-Lib candlestick pattern functions (CDL*) on the OHLCV data in {t}_ohlcv_4h_df. For each row, call all pattern functions and record the result values (integer outputs). Identify the active pattern by selecting the non-zero result if one exists.Identify if the pattern is a bullish or bearish variant if applicable.  Pass the detected candlestick pattern name as a string (e.g., \"Hammer\", \"Doji\", \"Engulfing Bullish\", \"No Pattern\" if all results are zero). If a single candle pattern and multi candle pattern present at the same time, then the multi candle pattern should always take priority. ",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "cmf_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.volume.ChaikinMoneyFlowIndicator(high  low  close  volume  window=60).chaikin_money_flow() adjustable settings to be added to config.py (defaults: Period=60)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_cmf_15m_df",
    "df_storage_period": 673,
    "df_keys": "timestamp  chaikin_money_flow",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "cmf_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.volume.ChaikinMoneyFlowIndicator(high  low  close  volume  window=60).chaikin_money_flow() adjustable settings to be added to config.py (defaults: Period=60)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_cmf_1h_df",
    "df_storage_period": 169,
    "df_keys": "timestamp  chaikin_money_flow",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "cmf_zscore_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_cmf_15m_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)({t}_cmf_15m_df['chaikin_money_flow'].iloc[-672:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "cmf_zscore_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_cmf_1h_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)({t}_cmf_1h_df['chaikin_money_flow'].iloc[-168:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "congestion_score",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": false,
    "transform_data_source": "gas_price_zscore_1h_df gas_used_zscore_4h_df",
    "transform": "gas_price_zscore_1h_df['gas_price_zscore_1h'].iloc[-1] * gas_used_zscore_4h_df['gas_used_zscore_4h'].iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "corr_spx_daily_30d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df {t}_close_spx_1d_df",
    "transform": "(np.log({t}_ohlcv_1d_df['close'] / ({t}_ohlcv_1d_df['close'].shift + 1e-9)(1))).rolling(window=30).corr(np.log(spx_close_1d_df['spx_close'] / spx_close_1d_df['spx_close'].shift(1))).iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "corr_spx_intraday_4h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_close_spx_15m_df",
    "transform": "(np.log({t}_ohlcv_15m_df['close'] / ({t}_ohlcv_15m_df['close'].shift + 1e-9)(1))).rolling(window=16).corr(np.log(spx_close_15m_df['spx_close_15m'] / spx_close_15m_df['spx_close_15m'].shift(1))).iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_corr_spx_intraday_4h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp corr_spx_intraday",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "cross_asset_contagion_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_close_spx_15m_df btc_ohlcv_15m_df",
    "transform": "crypto_returns = {t}_ohlcv_15m_df['close'].pct_change(); spx_returns = {t}_close_spx_15m_df['close'].pct_change(); btc_returns = btc_ohlcv_15m_df['close'].pct_change(); rolling_corr_spx = crypto_returns.rolling(96).corr(spx_returns); rolling_corr_btc = crypto_returns.rolling(96).corr(btc_returns); contagion_score = (rolling_corr_spx.abs() + rolling_corr_btc.abs()) * (crypto_returns.rolling(20).std() / crypto_returns.rolling(100).std()); contagion_score",
    "output_data_type": "float64",
    "output_data_unit": "contagion_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "cross_asset_momentum_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_momentum_confluence_15m_df, {t}_corr_spx_intraday_4h_df",
    "transform": "abs({t}_momentum_confluence_15m_df['momentum_confluence']) * abs({t}_corr_spx_intraday_4h_df['corr_spx_intraday'])",
    "output_data_type": "float64",
    "output_data_unit": "cross_momentum_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "cross_asset_volatility_spillover_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df {t}_close_spx_15m_df gold_close_15m_df",
    "transform": "token_vol = {t}_ohlcv_15m_df['close'].pct_change().rolling(20).std(); btc_vol = btc_ohlcv_15m_df['close'].pct_change().rolling(20).std(); spx_vol = {t}_close_spx_15m_df['close'].pct_change().rolling(20).std(); gold_vol = gold_close_15m_df['close'].pct_change().rolling(20).std(); vol_spillover_btc = token_vol.rolling(96).corr(btc_vol.shift(1)); vol_spillover_spx = token_vol.rolling(96).corr(spx_vol.shift(1)); vol_spillover_gold = token_vol.rolling(96).corr(gold_vol.shift(1)); spillover_index = (vol_spillover_btc + vol_spillover_spx + vol_spillover_gold) / 3; volatility_spillover = spillover_index * (token_vol.rolling(20).rank(pct=True)); volatility_spillover",
    "output_data_type": "float64",
    "output_data_unit": "spillover_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "cross_exchange_arbitrage_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_perp_close_1h_df {t}_basis_pct_15m_df",
    "transform": "spot_price = {t}_ohlcv_15m_df['close']; perp_price = {t}_perp_close_1h_df['perp_close'].reindex({t}_ohlcv_15m_df.index, method='ffill'); basis = {t}_basis_pct_15m_df['basis_pct']; price_divergence = (perp_price - spot_price) / spot_price; arbitrage_opportunity = price_divergence - basis; arbitrage_strength = arbitrage_opportunity * (abs(price_divergence).rolling(96).rank(pct=True)); cross_arbitrage = arbitrage_strength.rolling(20).rank(pct=True); cross_arbitrage",
    "output_data_type": "float64",
    "output_data_unit": "arbitrage_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "cross_market_beta_stability_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_close_spx_15m_df btc_ohlcv_15m_df",
    "transform": "token_ret = {t}_ohlcv_15m_df['close'].pct_change(); spx_ret = {t}_close_spx_15m_df['close'].pct_change(); btc_ret = btc_ohlcv_15m_df['close'].pct_change(); beta_spx = token_ret.rolling(96).cov(spx_ret) / (spx_ret.rolling(96).var() + 1e-9); beta_btc = token_ret.rolling(96).cov(btc_ret) / (btc_ret.rolling(96).var() + 1e-9); beta_stability = 1 / (beta_spx.rolling(20).std() + beta_btc.rolling(20).std() + 1e-9); cross_beta_stability = beta_stability * (abs(beta_spx - beta_btc).rolling(20).mean()); cross_beta_stability",
    "output_data_type": "float64",
    "output_data_unit": "stability_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "cross_timeframe_momentum_coherence_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ohlcv_1h_df {t}_ohlcv_4h_df {t}_ohlcv_1d_df",
    "transform": "mom_15m = {t}_ohlcv_15m_df['close'].pct_change(4); mom_1h = {t}_ohlcv_1h_df['close'].pct_change(4).reindex({t}_ohlcv_15m_df.index, method='ffill'); mom_4h = {t}_ohlcv_4h_df['close'].pct_change(4).reindex({t}_ohlcv_15m_df.index, method='ffill'); mom_1d = {t}_ohlcv_1d_df['close'].pct_change(4).reindex({t}_ohlcv_15m_df.index, method='ffill'); coherence = (np.sign(mom_15m) == np.sign(mom_1h)).astype(int) + (np.sign(mom_1h) == np.sign(mom_4h)).astype(int) + (np.sign(mom_4h) == np.sign(mom_1d)).astype(int); coherence_score = coherence * abs(mom_15m); coherence_score",
    "output_data_type": "float64",
    "output_data_unit": "coherence_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "crypto_fng_index_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d Fear and Greed  (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap)",
    "transform": "parse 'value' to 'crytpo_fng_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "int32",
    "output_data_unit": "score",
    "is_categorical_feature": false,
    "df_variable_id": "crypto_fng_1d_df",
    "df_storage_period": 108,
    "df_keys": "timestamp  crypto_fng_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "crypto_fng_zscore_90d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "crypto_fng_1d_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)(crypto_fng_1d_df['crypto_fng_1d'].iloc[-90:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "current_swing_strong_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_15m_df  ",
    "transform": "taken directly from {t}_smc_swing_15m_df",
    "output_data_type": "string",
    "output_data_unit": "strong or weak",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "current_swing_strong_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df  ",
    "transform": "taken directly from {t}_smc_swing_1h_df",
    "output_data_type": "string",
    "output_data_unit": "strong or weak",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "daily_sopr",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_network_profit_loss_1d_df {t}_transaction_volume_usd_1d_df",
    "transform": "{t}_transaction_volume_usd_1d_df['transaction_volume_usd_1d'].iloc[-1] / ({t}_transaction_volume_usd_1d_df['transaction_volume_usd_1d'].iloc[-1] - {t}_network_profit_loss_1d_df['network_profit_loss_1d'].iloc[-1])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "day_of_week_cos",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "cos(2piweekday_utc/7)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "day_of_week_sin",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "sin(2piweekday_utc/7)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "derivatives_dominance_ratio_24h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df {t}_ohlcv_15m_df",
    "transform": "(100 * {t}_oi_total_15m_df['oi_total_15m'].rolling(window=96).mean().iloc[-1]) / ({t}_ohlcv_15m_df['volume'].rolling(window=96).mean().iloc[-1] + 1e-6)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "derivatives_dominance_ratio_8h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df {t}_ohlcv_15m_df",
    "transform": "(100 * {t}_oi_total_15m_df['oi_total_15m'].rolling(window=32).mean().iloc[-1]) / ({t}_ohlcv_15m_df['volume'].rolling(window=32).mean().iloc[-1] + 1e-6)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=25) adjustable settings to be added to config.py (defaults: Period=25)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_di_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  adx_pos  adx_neg",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=35) adjustable settings to be added to config.py (defaults: Period=35)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_di_1d_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  adx_pos  adx_neg",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=25) adjustable settings to be added to config.py (defaults: Period=25)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_di_1h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  adx_pos  adx_neg",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.trend.ADXIndicator(high  low  close  window=21) adjustable settings to be added to config.py (defaults: Period=21)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_di_4h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  adx_pos  adx_neg",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_diff_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_di_15m_df",
    "transform": "{t}_di_15m_df['adx_pos']-{t}_di_15m_df['adx_neg']",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_diff_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_di_1d_df",
    "transform": "{t}_di_1d_df['adx_pos']-{t}_di_1d_df['adx_neg']",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_diff_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_di_1h_df",
    "transform": "{t}_di_1h_df['adx_pos']-{t}_di_1h_df['adx_neg']",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "di_diff_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_di_4h_df",
    "transform": "{t}_di_4h_df['adx_pos']-{t}_di_4h_df['adx_neg']",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "directional_adx_acceleration_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_15m_df",
    "transform": "({t}_adx_15m_df['adx'].iloc[-1] - df['adx'].iloc[-4]) * (1 if {t}_adx_15m_df['adx_pos'].iloc[-1] > {t}_adx_15m_df['adx_neg'].iloc[-1] else -1)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "directional_adx_acceleration_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_1d_df",
    "transform": "({t}_adx_1d_df['adx'].iloc[-1] - df['adx'].iloc[-4]) * (1 if {t}_adx_1d_df['adx_pos'].iloc[-1] > {t}_adx_1d_df['adx_neg'].iloc[-1] else -1)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "directional_adx_acceleration_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_1h_df",
    "transform": "({t}_adx_1h_df['adx'].iloc[-1] - df['adx'].iloc[-4]) * (1 if {t}_adx_1h_df['adx_pos'].iloc[-1] > {t}_adx_1h_df['adx_neg'].iloc[-1] else -1)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "directional_adx_acceleration_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_adx_4h_df",
    "transform": "({t}_adx_4h_df['adx'].iloc[-1] - df['adx'].iloc[-4]) * (1 if {t}_adx_4h_df['adx_pos'].iloc[-1] > {t}_adx_4h_df['adx_neg'].iloc[-1] else -1)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "directional_range_bias_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'] - {t}_ohlcv_15m_df['low']) - ({t}_ohlcv_15m_df['high'] - {t}_ohlcv_15m_df['close'])) / ({t}_ohlcv_15m_df['high'] - {t}_ohlcv_15m_df['low'] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_from_last_ms_event_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_15m_df  {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_event_15m_df.iloc[-1]['smc_event_price']) / {t}_smc_event_15m_df.iloc[-1]['smc_event_price']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_from_last_ms_event_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_1h_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_event_1h_df.iloc[-1]['smc_event_price']) / {t}_smc_event_1h_df.iloc[-1]['smc_event_price']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_from_last_ms_event_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_4h_df {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_event_4h_df.iloc[-1]['smc_event_price']) / {t}_smc_event_4h_df.iloc[-1]['smc_event_price']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_avwap_pc",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_vwap_1d_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_vwap_1d_df['volume_weighted_average_price'].iloc[-1]) / {t}_vwap_1d_df['volume_weighted_average_price'].iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_daily_pivot_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_pivot_points_1d_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_pivot_points_1d_df['pivot'].iloc[-1]) / {t}_pivot_points_1d_df['pivot'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_daily_r1_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_pivot_points_1d_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_pivot_points_1d_df['r1'].iloc[-1]) / {t}_pivot_points_1d_df['r1'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_daily_s1_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_pivot_points_1d_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_pivot_points_1d_df['s1'].iloc[-1]) / {t}_pivot_points_1d_df['s1'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bear_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bearish FVG\nlast_bearish_fvg = {t}_smc_fvg_15m_df[({t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_15m_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_bottom_price = last_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_bottom_price) / fvg_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bear_pct_n1_1d_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1d_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bearish FVG\nlast_bearish_fvg = {t}_smc_fvg_1d_df[({t}_smc_fvg_1d_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_1d_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_bottom_price = last_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_bottom_price) / fvg_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bear_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bearish FVG\nlast_bearish_fvg = {t}_smc_fvg_1h_df[({t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_1h_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_bottom_price = last_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_bottom_price) / fvg_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bear_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_4h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bearish FVG\nlast_bearish_fvg = {t}_smc_fvg_4h_df[({t}_smc_fvg_4h_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_4h_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_bottom_price = last_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_bottom_price) / fvg_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bull_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bullish FVG\nlast_bearish_fvg = {t}_smc_fvg_15m_df[({t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_15m_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_top_price = last_bullish_fvg['smc_fvg_top'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_top_price) / fvg_top_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bull_pct_n1_1d_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1d_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bullish FVG\nlast_bearish_fvg = {t}_smc_fvg_1d_df[({t}_smc_fvg_1d_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_1d_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_top_price = last_bullish_fvg['smc_fvg_top'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_top_price) / fvg_top_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bull_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df  {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bullish FVG\nlast_bearish_fvg = {t}_smc_fvg_1h_df[({t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_1h_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_top_price = last_bullish_fvg['smc_fvg_top'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_top_price) / fvg_top_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_fvg_bull_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_4h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bullish FVG\nlast_bearish_fvg = {t}_smc_fvg_4h_df[({t}_smc_fvg_4h_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_4h_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that FVG\nfvg_top_price = last_bullish_fvg['smc_fvg_top'];\n\n# 3. Calculate the percentage distance from the current close to the FVG's bottom\n(({t}_ohlcv_15m_df['close'].iloc[-1] - fvg_top_price) / fvg_top_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_high_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_smc_swing_15m_df  ",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_high_pct_n1_1d_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_high_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_high_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_low_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_smc_swing_15m_df  ",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_low_pct_n1_1d_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_low_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_last_low_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df   {t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) / {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low'].iloc[-1]['smc_last_pivot_candidate_level']) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_fvg_bear_pct_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bearish FVG\nlast_mitigated_bearish_fvg = {t}_smc_fvg_15m_df[({t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_15m_df['smc_fvg_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the top and bottom prices of that FVG\nfvg_top_price = last_mitigated_bearish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_mitigated_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the mitigated price (50% level of the FVG)\nmitigated_fvg_price = (fvg_top_price + fvg_bottom_price) / 2;\n\n# 4. Calculate the percentage distance from the current close to the mitigated price\n(({t}_ohlcv_15m_df['close'].iloc[-1] - mitigated_fvg_price) / mitigated_fvg_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_fvg_bear_pct_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bearish FVG\nlast_mitigated_bearish_fvg = {t}_smc_fvg_1h_df[({t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_1h_df['smc_fvg_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the top and bottom prices of that FVG\nfvg_top_price = last_mitigated_bearish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_mitigated_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the mitigated price (50% level of the FVG)\nmitigated_fvg_price = (fvg_top_price + fvg_bottom_price) / 2;\n\n# 4. Calculate the percentage distance from the current close to the mitigated price\n(({t}_ohlcv_15m_df['close'].iloc[-1] - mitigated_fvg_price) / mitigated_fvg_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_fvg_bull_pct_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bullish FVG\nlast_mitigated_bullish_fvg = {t}_smc_fvg_15m_df[({t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_15m_df['smc_fvg_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the top and bottom prices of that FVG\nfvg_top_price = last_mitigated_bullish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_mitigated_bullish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the mitigated price (50% level of the FVG)\nmitigated_fvg_price = (fvg_top_price + fvg_bottom_price) / 2;\n\n# 4. Calculate the percentage distance from the current close to the mitigated price\n(({t}_ohlcv_15m_df['close'].iloc[-1] - mitigated_fvg_price) / mitigated_fvg_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_fvg_bull_pct_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bullish FVG\nlast_mitigated_bullish_fvg = {t}_smc_fvg_1h_df[({t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_1h_df['smc_fvg_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the top and bottom prices of that FVG\nfvg_top_price = last_mitigated_bullish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_mitigated_bullish_fvg['smc_fvg_bottom'];\n\n# 3. Calculate the mitigated price (50% level of the FVG)\nmitigated_fvg_price = (fvg_top_price + fvg_bottom_price) / 2;\n\n# 4. Calculate the percentage distance from the current close to the mitigated price\n(({t}_ohlcv_15m_df['close'].iloc[-1] - mitigated_fvg_price) / mitigated_fvg_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_ob_bear_pct_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bearish Order Block\nlast_mitigated_bear_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nlast_mitigated_bear_ob_bottom_price = last_mitigated_bear_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((last_mitigated_bear_ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / last_mitigated_bear_ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_ob_bear_pct_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bearish Order Block\nlast_mitigated_bear_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nlast_mitigated_bear_ob_bottom_price = last_mitigated_bear_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((last_mitigated_bear_ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / last_mitigated_bear_ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_ob_bull_pct_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bullish Order Block\nlast_mitigated_bull_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nlast_mitigated_bull_ob_bottom_price = last_mitigated_bull_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((last_mitigated_bull_ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / last_mitigated_bull_ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_mitig_ob_bull_pct_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *mitigated*  bullish Order Block\nlast_mitigated_bull_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'mitigated')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nlast_mitigated_bull_ob_bottom_price = last_mitigated_bull_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((last_mitigated_bull_ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / last_mitigated_bull_ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bear_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bear_pct_n1_1d_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1d_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_1d_df[({t}_smc_ob_1d_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_1d_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bear_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bear_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_4h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_4h_df[({t}_smc_ob_4h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_4h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bull_pct_n1_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bull_pct_n1_1d_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1d_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_1d_df[({t}_smc_ob_1d_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_1d_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bull_pct_n1_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_ob_bull_pct_n1_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_4h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_4h_df[({t}_smc_ob_4h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_4h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the bottom price of that Order Block\nob_bottom_price = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Calculate the percentage distance from the current close to the OB's bottom price\n((ob_bottom_price - {t}_ohlcv_15m_df['close'].iloc[-1]) / ob_bottom_price) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_prev_day_high_pct_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ohlcv_1d_df",
    "transform": "(100 * ({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_ohlcv_1d_df['high'].iloc[-2])) / {t}_ohlcv_1d_df['high'].iloc[-2]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_prev_day_low_pct_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ohlcv_1d_df",
    "transform": "(100 * ({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_ohlcv_1d_df['low'].iloc[-2])) / {t}_ohlcv_1d_df['low'].iloc[-2]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_prev_week_high_pct_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ohlcv_7d_df",
    "transform": "(100 * ({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_ohlcv_7d_df['high'].iloc[-2])) / {t}_ohlcv_7d_df['high'].iloc[-2]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_prev_week_low_pct_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ohlcv_7d_df",
    "transform": "(100 * ({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_ohlcv_7d_df['low'].iloc[-2])) / {t}_ohlcv_7d_df['low'].iloc[-2]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_vwap_30d_pct",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_vwap30d_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_vwap30d_df['volume_weighted_average_price'].iloc[-1]) / {t}_vwap30d_df['volume_weighted_average_price'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_vwap_5d_1h_pct",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df  {t}_vwap_5d_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_vwap_5d_df['volume_weighted_average_price'].iloc[-1]) / {t}_vwap_5d_df['volume_weighted_average_price'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dist_to_weekly_pivot_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_pivot_points_7d_df",
    "transform": "(({t}_ohlcv_15m_df['close'].iloc[-1] - {t}_pivot_points_7d_df['pivot'].iloc[-1]) / {t}_pivot_points_7d_df['pivot'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "donchian_breakout_20",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "{t}_ohlcv_15m_df['high'] > ta.volatility.DonchianChannel({t}_ohlcv_15m_df['high']  {t}_ohlcv_15m_df['low']  window=20).donchian_channel_hband().shift(1)",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dxy_close_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get DX-Y.NYB data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse 'close' to 'dxy_close_15m' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "dxy_close_15m_df",
    "df_storage_period": 70,
    "df_keys": "timestamp  dxy_close_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dxy_close_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get DX-Y.NYB data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse 'close' to 'dxy_close_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "dxy_close_1d_df",
    "df_storage_period": 70,
    "df_keys": "timestamp  dxy_close_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dxy_ema_divergence_21d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": false,
    "transform_data_source": "dxy_close_1d_df dxy_ema21_1d_df",
    "transform": "(100 * (dxy_close_1d_df['close'].iloc[-21:] - dxy_ema21_1d_df['ema_indicator'].iloc[-21:]) / dxy_ema21_1d_df['ema_indicator'].iloc[-21:]).mean()",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dxy_ema21_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "dxy_close_1d_df",
    "transform": "ta.trend.EMAIndicator(close  window=21).ema_indicator() adjustable settings to be added to config.py (defaults: Period=21)",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "dxy_ema21_1d_df",
    "df_storage_period": 21,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "dxy_return_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "dxy_df_close_1h_df",
    "transform": "np.log1p(dxy_close_15m_df['close'].pct_change(periods=4).iloc[-1])",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "economic_event",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live: 1d Economic Calendar Events (Refer to Unicorn_Wealth_API_Reference Guide 4.0 Finnhub)",
    "transform": "if any JSON object returned has \"impact\" value \"high\" within the returned data AND the event date is within 24 hours of now  then \"economic_event\" df column = TRUE  otherwise FALSE.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "economic_event_df",
    "df_storage_period": 2,
    "df_keys": "economic_event",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_breakout_signal_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df {t}_ema_slow_1d_df {t}_ohlcv_1d_df",
    "transform": "((abs({t}_ema_fast_1d_df['ema_indicator'] - {t}_ema_slow_1d_df['ema_indicator']) / {t}_ohlcv_1d_df['close'] * 100) > ((abs({t}_ema_fast_1d_df['ema_indicator'] - {t}_ema_slow_1d_df['ema_indicator']) / {t}_ohlcv_1d_df['close'] * 100).rolling(20).mean() * 1.5)) & (np.where(({t}_ema_fast_1d_df['ema_indicator'].pct_change(1) > 0) & ({t}_ema_mid_1d_df['ema_indicator'].pct_change(1) > 0) & ({t}_ema_slow_1d_df['ema_indicator'].pct_change(1) > 0)  1  np.where(({t}_ema_fast_1d_df['ema_indicator'].pct_change(1) < 0) & ({t}_ema_mid_1d_df['ema_indicator'].pct_change(1) < 0) & ({t}_ema_slow_1d_df['ema_indicator'].pct_change(1) < 0)  -1  0)) != 0) & (np.where(({t}_ema_fast_1d_df['ema_indicator'] > {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_fast_1d_df['ema_indicator'].shift(1) <= {t}_ema_mid_1d_df['ema_indicator'].shift(1))  1  np.where(({t}_ema_fast_1d_df['ema_indicator'] < {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_fast_1d_df['ema_indicator'].shift(1) >= {t}_ema_mid_1d_df['ema_indicator'].shift(1))  -1  0)) != 0)).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_fast_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.EMAIndicator(close  window=15).ema_indicator() adjustable settings to be added to config.py (defaults: Period=15)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_fast_15m_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_fast_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.trend.EMAIndicator(close  window=15).ema_indicator() adjustable settings to be added to config.py (defaults: Period=15)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_fast_1d_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_fast_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.EMAIndicator(close  window=15).ema_indicator() adjustable settings to be added to config.py (defaults: Period=15)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_fast_1h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_fast_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.trend.EMAIndicator(close  window=15).ema_indicator() adjustable settings to be added to config.py (defaults: Period=15)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_fast_4h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_mid_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.EMAIndicator(close  window=70).ema_indicator() adjustable settings to be added to config.py (defaults: Period=70)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_mid_15m_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_mid_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.trend.EMAIndicator(close  window=70).ema_indicator() adjustable settings to be added to config.py (defaults: Period=65)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_mid_1d_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_mid_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.EMAIndicator(close  window=70).ema_indicator() adjustable settings to be added to config.py (defaults: Period=70)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_mid_1h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_mid_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.trend.EMAIndicator(close  window=70).ema_indicator() adjustable settings to be added to config.py (defaults: Period=70)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_mid_4h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_momentum_quality_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df",
    "transform": "ema_fast_slope = {t}_ema_fast_1d_df['ema_indicator'].pct_change(1); ema_medium_slope = {t}_ema_mid_1d_df['ema_indicator'].pct_change(1); momentum_strength = abs({t}_ema_fast_1d_df['ema_indicator'].pct_change(5)); trend_consistency = 1 - (abs(ema_fast_slope - ema_medium_slope) / (abs(ema_fast_slope) + abs(ema_medium_slope) + 1e-9)); momentum_strength * trend_consistency",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_momentum_quality_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_4h_df {t}_ema_mid_4h_df",
    "transform": "ema_fast_slope = {t}_ema_fast_4h_df['ema_indicator'].pct_change(1); ema_medium_slope = {t}_ema_mid_4h_df['ema_indicator'].pct_change(1); momentum_strength = abs({t}_ema_fast_4h_df['ema_indicator'].pct_change(5)); trend_consistency = 1 - (abs(ema_fast_slope - ema_medium_slope) / (abs(ema_fast_slope) + abs(ema_medium_slope) + 1e-9)); momentum_strength * trend_consistency",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_signal_strength_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df {t}_ema_slow_1d_df",
    "transform": "(0.30 * np.tanh(np.where(({t}_ema_fast_1d_df['ema_indicator'] > {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_fast_1d_df['ema_indicator'].shift(1) <= {t}_ema_mid_1d_df['ema_indicator'].shift(1))  1  np.where(({t}_ema_fast_1d_df['ema_indicator'] < {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_fast_1d_df['ema_indicator'].shift(1) >= {t}_ema_mid_1d_df['ema_indicator'].shift(1))  -1  0)) * 2)) + (0.25 * np.where(({t}_ema_fast_1d_df['ema_indicator'].pct_change(1) > 0) & ({t}_ema_mid_1d_df['ema_indicator'].pct_change(1) > 0) & ({t}_ema_slow_1d_df['ema_indicator'].pct_change(1) > 0)  1  np.where(({t}_ema_fast_1d_df['ema_indicator'].pct_change(1) < 0) & ({t}_ema_mid_1d_df['ema_indicator'].pct_change(1) < 0) & ({t}_ema_slow_1d_df['ema_indicator'].pct_change(1) < 0)  -1  0))) + (0.25 * ((({t}_ema_fast_1d_df['ema_indicator'] > {t}_ema_mid_1d_df['ema_indicator']) & ({t}_ema_mid_1d_df['ema_indicator'] > {t}_ema_slow_1d_df['ema_indicator'])).astype(int) * 2) - 1)) + (0.20 * np.tanh(abs({t}_ema_fast_1d_df['ema_indicator'].pct_change(5)) * 100 / 10))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_slow_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.EMAIndicator(close  window=100).ema_indicator() adjustable settings to be added to config.py (defaults: Period=100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_slow_15m_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_slow_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.trend.EMAIndicator(close  window=100).ema_indicator() adjustable settings to be added to config.py (defaults: Period=80)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_slow_1d_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_slow_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.EMAIndicator(close  window=100).ema_indicator() adjustable settings to be added to config.py (defaults: Period=100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_slow_1h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ema_slow_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.trend.EMAIndicator(close  window=100).ema_indicator() adjustable settings to be added to config.py (defaults: Period=100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ema_slow_4h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "eth_btc_mcap_ratio_growth_7d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_mcap_1d_df btc_mcap_1d_df",
    "transform": "(eth_mcap_1d_df['eth_mcap_1d'].iloc[-1] / (btc_mcap_1d_df['btc_mcap_1d'].iloc[-1] + 1e-9)) / (eth_mcap_1d_df['eth_mcap_1d'].iloc[-9] / btc_mcap_1d_df['btc_mcap_1d'].iloc[-9]) - 1",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "eth_btc_ratio_zscore_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "(eth_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['close'] + 1e-9) - (eth_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['close'] + 1e-9)).rolling(window=20).mean()) / (eth_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_ratio_zscore_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "(eth_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['close'] + 1e-9) - (eth_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['close'] + 1e-9)).rolling(window=20).mean()) / (eth_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_ratio_zscore_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "(eth_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['close'] + 1e-9) - (eth_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['close'] + 1e-9)).rolling(window=20).mean()) / (eth_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_ratio_zscore_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "(eth_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['close'] + 1e-9) - (eth_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['close'] + 1e-9)).rolling(window=20).mean()) / (eth_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "(eth_ohlcv_15m_df['volume'] * eth_ohlcv_15m_df['close']) / (btc_ohlcv_15m_df['volume'] * btc_ohlcv_15m_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "(eth_ohlcv_1d_df['volume'] * eth_ohlcv_1d_df['close']) / (btc_ohlcv_1d_df['volume'] * btc_ohlcv_1d_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "(eth_ohlcv_1h_df['volume'] * eth_ohlcv_1h_df['close']) / (btc_ohlcv_1h_df['volume'] * btc_ohlcv_1h_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "(eth_ohlcv_4h_df['volume'] * eth_ohlcv_4h_df['close']) / (btc_ohlcv_4h_df['volume'] * btc_ohlcv_4h_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_sma12_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "(eth_ohlcv_4h_df['volume'] * eth_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['volume'] * btc_ohlcv_4h_df['close'])).rolling(window=12).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_sma20_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "(eth_ohlcv_15m_df['volume'] * eth_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['volume'] * btc_ohlcv_15m_df['close'])).rolling(window=20).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_sma24_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "(eth_ohlcv_1h_df['volume'] * eth_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['volume'] * btc_ohlcv_1h_df['close'])).rolling(window=24).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_dollar_volume_sma7_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "(eth_ohlcv_1d_df['volume'] * eth_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['volume'] * btc_ohlcv_1d_df['close'])).rolling(window=7).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_momentum_pct_1p_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "eth_ohlcv_1d_df['close'].pct_change(periods=1) - btc_ohlcv_1d_df['close'].pct_change(periods=1)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_momentum_pct_3p_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "eth_ohlcv_15m_df['close'].pct_change(periods=3) - btc_ohlcv_15m_df['close'].pct_change(periods=3)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_momentum_pct_4p_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "eth_ohlcv_4h_df['close'].pct_change(periods=4) - btc_ohlcv_4h_df['close'].pct_change(periods=4)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_momentum_pct_6p_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "eth_ohlcv_1h_df['close'].pct_change(periods=6) - btc_ohlcv_1h_df['close'].pct_change(periods=6)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_volatility_12p_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "eth_ohlcv_4h_df['close'].pct_change().rolling(window=12).std() / btc_ohlcv_4h_df['close'].pct_change().rolling(window=12).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_volatility_20p_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "eth_ohlcv_15m_df['close'].pct_change().rolling(window=20).std() / btc_ohlcv_15m['close'].pct_change().rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_volatility_24p_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "eth_ohlcv_1h_df['close'].pct_change().rolling(window=24).std() / btc_ohlcv_1h_df['close'].pct_change().rolling(window=24).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_btc_relative_volatility_7p_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "eth_ohlcv_1d_df['close'].pct_change().rolling(window=7).std() / btc_ohlcv_1d_df['close'].pct_change().rolling(window=7).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_funding_rate_zscore_7d",
    "live_cadence": "30m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_funding_rate_30m_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)(eth_funding_rate_30m_df['last'].iloc[-336:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "eth_mcap_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d ETH Market Cap from Cryptocurrency Quotes Historical v2 (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap) ",
    "transform": "parse 'market_cap' to 'eth_mcap_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "eth_mcap_1d_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  eth_mcap_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_option_oi_pct_change_24h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_oi_total_15m_df",
    "transform": "eth_oi_total_15m_df['oi_total_15m'].pct_change(periods=96).iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "eth_supply_usd_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:15m ETH Circulating Supply from Cryptocurrency Quotes Historical v2 (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap)",
    "transform": "parse 'circulating_supply' to 'eth_supply_15m' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "eth_supply_usd_15m_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  eth_supply_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "eth_vs_alts_perf_10d_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "eth_ohlcv_1d_df btc_ohlcv_1d_df total_mcap_close_1d_df btc_circ_supply_1d_df",
    "transform": "((eth_ohlcv_1d_df['close'].iloc[-1] / (eth_ohlcv_1d_df['close'].iloc[-11] + 1e-9)) / ((total_mcap_close_1d_df['total_market_cap_1d'].iloc[-1] - (btc_ohlcv_1d_df['close'].iloc[-1] * btc_circ_supply_1d_df['btc_supply_1d'].iloc[-1])) / (total_mcap_close_1d_df['total_market_cap_1d'].iloc[-11] - (btc_ohlcv_1d_df['close'].iloc[-11] * btc_circ_supply_1d_df['btc_supply_1d'].iloc[-11])))) - 1",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "exchg_supply_zscore_7d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_percent_of_total_supply_on_exchanges_1d_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)({t}_percent_of_total_supply_on_exchanges_1d_df['percent_of_total_supply_on_exchanges_1d'].iloc[-7:])",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "exchg_supply_zscore_90d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_percent_of_total_supply_on_exchanges_1d_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)({t}_percent_of_total_supply_on_exchanges_1d_df['percent_of_total_supply_on_exchanges_1d'].iloc[-90:])",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fees_burnt_usd_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:15m Fees Burnt USD (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'fees_burnt_usd_15m' df column. All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "fees_burnt_usd_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  fees_burnt_usd_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fees_usd_intraday_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:15m Fees USD Intraday (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'fees_usd_intraday_15m' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "fees_usd_intraday_df",
    "df_storage_period": 168,
    "df_keys": "timestamp  fees_usd_intraday_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fees_usd_intraday_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "{t}_fees_usd_intraday_15m_df",
    "transform": "aggregate 15m {t}_fees_usd_intraday_15m_df  values and save to {t}_fees_usd_intraday_1h_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "fees_usd_intraday_1h_df",
    "df_storage_period": 169,
    "df_keys": "timestamp  fees_usd_intraday_1h",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fees_usd_zscore_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "fees_usd_intraday_1h_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / (s.std() + 1e-9) if s.notna().sum() > 1 else 0.0)(fees_usd_1h_df['fees_usd_intraday_1h'].iloc[-168:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_extension_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_15m_df",
    "transform": "1 Isolate the Three-Point Structure: Access the {t}_smc_swing_15m_df dataframe and retrieve the last three confirmed swings in chronological order These will be our Point A Point B and Point C 2 Define the Swings: Point A The price level smc_last_pivot_candidate_level of the third-to-last swing Point B The price level of the second-to-last swing Point C The price level of the most recent swing 3 Calculate the Impulse Wave: The agent determines the height of the initial impulse wave by finding the absolute difference between Point A and Point B abs(Point_B - Point_A) 4 Project and Calculate Levels: If the impulse was upward Point_B > Point_A the agent projects targets by adding the impulse height multiplied by the extension ratios to the retracement price at Point C Formula level = Point_C + (impulse_height * fib_ratio) If the impulse was downward Point_B < Point_A it projects targets by subtracting the impulse height from Point C Formula level = Point_C - (impulse_height * fib_ratio) 5 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 1236 1382 15 1618 2618",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_extension_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 1236 1382 15 1618 2618",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_extension_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_1d_df",
    "transform": "1 Isolate the Three-Point Structure: Access the {t}_smc_swing_1d_df dataframe and retrieve the last three confirmed swings in chronological order These will be our Point A Point B and Point C 2 Define the Swings: Point A The price level smc_last_pivot_candidate_level of the third-to-last swing Point B The price level of the second-to-last swing Point C The price level of the most recent swing 3 Calculate the Impulse Wave: The agent determines the height of the initial impulse wave by finding the absolute difference between Point A and Point B abs(Point_B - Point_A) 4 Project and Calculate Levels: If the impulse was upward Point_B > Point_A the agent projects targets by adding the impulse height multiplied by the extension ratios to the retracement price at Point C Formula level = Point_C + (impulse_height * fib_ratio) If the impulse was downward Point_B < Point_A it projects targets by subtracting the impulse height from Point C Formula level = Point_C - (impulse_height * fib_ratio) 5 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 1236 1382 15 1618 2618",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_extension_1d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 1236 1382 15 1618 2618",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_extension_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_1h_df",
    "transform": "1 Isolate the Three-Point Structure: Access the {t}_smc_swing_1h_df dataframe and retrieve the last three confirmed swings in chronological order These will be our Point A Point B and Point C 2 Define the Swings: Point A The price level smc_last_pivot_candidate_level of the third-to-last swing Point B The price level of the second-to-last swing Point C The price level of the most recent swing 3 Calculate the Impulse Wave: The agent determines the height of the initial impulse wave by finding the absolute difference between Point A and Point B abs(Point_B - Point_A) 4 Project and Calculate Levels: If the impulse was upward Point_B > Point_A the agent projects targets by adding the impulse height multiplied by the extension ratios to the retracement price at Point C Formula level = Point_C + (impulse_height * fib_ratio) If the impulse was downward Point_B < Point_A it projects targets by subtracting the impulse height from Point C Formula level = Point_C - (impulse_height * fib_ratio) 5 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 1236 1382 15 1618 2618",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_extension_1h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 1236 1382 15 1618 2618",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_extension_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_4h_df",
    "transform": "1 Isolate the Three-Point Structure: Access the {t}_smc_swing_4h_df dataframe and retrieve the last three confirmed swings in chronological order These will be our Point A Point B and Point C 2 Define the Swings: Point A The price level smc_last_pivot_candidate_level of the third-to-last swing Point B The price level of the second-to-last swing Point C The price level of the most recent swing 3 Calculate the Impulse Wave: The agent determines the height of the initial impulse wave by finding the absolute difference between Point A and Point B abs(Point_B - Point_A) 4 Project and Calculate Levels: If the impulse was upward Point_B > Point_A the agent projects targets by adding the impulse height multiplied by the extension ratios to the retracement price at Point C Formula level = Point_C + (impulse_height * fib_ratio) If the impulse was downward Point_B < Point_A it projects targets by subtracting the impulse height from Point C Formula level = Point_C - (impulse_height * fib_ratio) 5 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 1236 1382 15 1618 2618",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_extension_4h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 1236 1382 15 1618 2618",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_extension_dist_pct_15m_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_extension_15m_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_extension_15m_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_extension_15m_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_extension_dist_pct_1d_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_extension_1d_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_extension_1d_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_extension_1d_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_extension_dist_pct_1h_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_extension_1h_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_extension_1h_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_extension_1h_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_extension_dist_pct_4h_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_extension_4h_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_extension_4h_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_extension_4h_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_level_tested_count_618_15m_50",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_15m_df {t}_ohlcv_15m_df {t}_fib_retracement_15m_df",
    "transform": "(({t}_ohlcv_15m_df['timestamp'] >= {t}_smc_swing_15m_df['smc_swing_confirmation_time'].iloc[-1]) & ({t}_ohlcv_15m_df['low'] <= {t}_fib_retracement_15m_df['0618'].iloc[-1]) & ({t}_ohlcv_15m_df['high'] >= {t}_fib_retracement_15m_df['0618'].iloc[-1])).sum()",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_level_tested_count_618_1d_50",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df {t}_ohlcv_15m_df {t}_fib_retracement_1d_df",
    "transform": "(({t}_ohlcv_15m_df['timestamp'] >= {t}_smc_swing_1d_df['smc_swing_confirmation_time'].iloc[-1]) & ({t}_ohlcv_15m_df['low'] <= {t}_fib_retracement_1d_df['0618'].iloc[-1]) & ({t}_ohlcv_15m_df['high'] >= {t}_fib_retracement_1d_df['0618'].iloc[-1])).sum()",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_level_tested_count_618_1h_50",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df {t}_ohlcv_15m_df {t}_fib_retracement_1h_df",
    "transform": "(({t}_ohlcv_15m_df['timestamp'] >= {t}_smc_swing_1h_df['smc_swing_confirmation_time'].iloc[-1]) & ({t}_ohlcv_15m_df['low'] <= {t}_fib_retracement_1h_df['0618'].iloc[-1]) & ({t}_ohlcv_15m_df['high'] >= {t}_fib_retracement_1h_df['0618'].iloc[-1])).sum()",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_level_tested_count_618_4h_50",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df {t}_ohlcv_15m_df {t}_fib_retracement_4h_df",
    "transform": "(({t}_ohlcv_15m_df['timestamp'] >= {t}_smc_swing_4h_df['smc_swing_confirmation_time'].iloc[-1]) & ({t}_ohlcv_15m_df['low'] <= {t}_fib_retracement_4h_df['0618'].iloc[-1]) & ({t}_ohlcv_15m_df['high'] >= {t}_fib_retracement_4h_df['0618'].iloc[-1])).sum()",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_retracement_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_15m_df",
    "transform": "1 Isolate Key Swings: Access the {t}_smc_swing_15m_df dataframe Find the most recent swing high and the most recent swing low by filtering the smc_swing_type column and selecting the last entry for each 2 Determine the Primary Move: Compare the smc_swing_confirmation_time of the identified swing high and swing low to determine which one is more recent This defines the end of the primary move 3 Calculate Levels: If the swing high is more recent an upward move the agent calculates the retracement levels by subtracting percentages of the total move's height from the high price Formula level = high_price - (high_price - low_price) * fib_ratio If the swing low is more recent a downward move it calculates levels by adding percentages of the move's height to the low price Formula level = low_price + (high_price - low_price) * fib_ratio 4 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 0236 0382 05 0618 0786",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_retracement_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 0236 0382 05 0618 0786",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_retracement_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_1d_df",
    "transform": "1 Isolate Key Swings: Access the {t}_smc_swing_1d_df dataframe Find the most recent swing high and the most recent swing low by filtering the smc_swing_type column and selecting the last entry for each 2 Determine the Primary Move: Compare the smc_swing_confirmation_time of the identified swing high and swing low to determine which one is more recent This defines the end of the primary move 3 Calculate Levels: If the swing high is more recent an upward move the agent calculates the retracement levels by subtracting percentages of the total move's height from the high price Formula level = high_price - (high_price - low_price) * fib_ratio If the swing low is more recent a downward move it calculates levels by adding percentages of the move's height to the low price Formula level = low_price + (high_price - low_price) * fib_ratio 4 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 0236 0382 05 0618 0786",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_retracement_1d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 0236 0382 05 0618 0786",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_retracement_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_1h_df",
    "transform": "1 Isolate Key Swings: Access the {t}_smc_swing_1h_df dataframe Find the most recent swing high and the most recent swing low by filtering the smc_swing_type column and selecting the last entry for each 2 Determine the Primary Move: Compare the smc_swing_confirmation_time of the identified swing high and swing low to determine which one is more recent This defines the end of the primary move 3 Calculate Levels: If the swing high is more recent an upward move the agent calculates the retracement levels by subtracting percentages of the total move's height from the high price Formula level = high_price - (high_price - low_price) * fib_ratio If the swing low is more recent a downward move it calculates levels by adding percentages of the move's height to the low price Formula level = low_price + (high_price - low_price) * fib_ratio 4 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 0236 0382 05 0618 0786",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_retracement_1h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 0236 0382 05 0618 0786",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_retracement_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_4h_df",
    "transform": "1 Isolate Key Swings: Access the {t}_smc_swing_4h_df dataframe Find the most recent swing high and the most recent swing low by filtering the smc_swing_type column and selecting the last entry for each 2 Determine the Primary Move: Compare the smc_swing_confirmation_time of the identified swing high and swing low to determine which one is more recent This defines the end of the primary move 3 Calculate Levels: If the swing high is more recent an upward move the agent calculates the retracement levels by subtracting percentages of the total move's height from the high price Formula level = high_price - (high_price - low_price) * fib_ratio If the swing low is more recent a downward move it calculates levels by adding percentages of the move's height to the low price Formula level = low_price + (high_price - low_price) * fib_ratio 4 Output: save returned values into the dataframe as defined in df_variable_id with df_keys 0236 0382 05 0618 0786",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_retracement_4h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp 0236 0382 05 0618 0786",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fib_retracement_dist_pct_15m_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_15m_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_retracement_15m_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_retracement_15m_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_fib_retracement_dist_pct_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp fib_retracement_dist_pct",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_retracement_dist_pct_1d_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_1d_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_retracement_1d_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_retracement_1d_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_retracement_dist_pct_1h_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_1h_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_retracement_1h_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_retracement_1h_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fib_retracement_dist_pct_4h_n1",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_4h_df {t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'].iloc[-1] - ({t}_fib_retracement_4h_df.drop('timestamp', axis=1).iloc[-1]).iloc[({t}_fib_retracement_4h_df.drop('timestamp', axis=1).iloc[-1] - {t}_ohlcv_15m_df['close'].iloc[-1]).abs().argsort()[0]]) / {t}_ohlcv_15m_df['close'].iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "fibonacci_volume_confluence_15m",
    "live_cadence": "15m",
    "step_order": 5,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_dist_pct_15m_df, {t}_volume_zscore_20_15m_df",
    "transform": "abs({t}_fib_retracement_dist_pct_15m_df['fib_retracement_dist_pct']) *{t}_volume_zscore_20_15m_df['volume_zscore_20']",
    "output_data_type": "float64",
    "output_data_unit": "confluence_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "fm_cross_signal_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_15m_df {t}_ema_mid_15m_df",
    "transform": "np.where(({t}_ema_fast_15m_df['ema_indicator'] > {t}_ema_mid_15m_df['ema_indicator']) & ({t}_ema_fast_15m_df['ema_indicator'].shift(1) <= {t}_ema_mid_15m_df['ema_indicator'].shift(1))  1  np.where(({t}_ema_fast_15m_df['ema_indicator'] < {t}_ema_mid_15m_df['ema_indicator']) & ({t}_ema_fast_15m_df['ema_indicator'].shift(1) >= {t}_ema_mid_15m_df['ema_indicator'].shift(1))  -1  0))",
    "output_data_type": "int32",
    "output_data_unit": " -1  0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fm_cross_signal_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1h_df {t}_ema_mid_1h_df",
    "transform": "np.where(({t}_ema_fast_1h_df['ema_indicator'] > {t}_ema_mid_1h_df['ema_indicator']) & ({t}_ema_fast_1h_df['ema_indicator'].shift(1) <= {t}_ema_mid_1h_df['ema_indicator'].shift(1))  1  np.where(({t}_ema_fast_1h_df['ema_indicator'] < {t}_ema_mid_1h_df['ema_indicator']) & ({t}_ema_fast_1h_df['ema_indicator'].shift(1) >= {t}_ema_mid_1h_df['ema_indicator'].shift(1))  -1  0))",
    "output_data_type": "int32",
    "output_data_unit": " -1 0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fractal_dimension_trend_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "price = {t}_ohlcv_15m_df['close']; log_price = np.log(price + 1e-9); n = 20; r_values = [1, 2, 4, 8]; rs_values = []; for r in r_values: segments = [log_price.iloc[i:i+r] for i in range(0, len(log_price)-r+1, r)]; rs = np.mean([np.max(seg) - np.min(seg) for seg in segments if len(seg) == r]); rs_values.append(rs); fractal_dim = -np.polyfit(np.log(r_values), np.log(rs_values + 1e-9), 1)[0]; fractal_dimension = pd.Series([fractal_dim] * len(price), index=price.index); fractal_dimension",
    "output_data_type": "float64",
    "output_data_unit": "fractal_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "friday_flag",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. TRUE if day of week = Friday",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "funding_arbitrage_signal_15m",
    "live_cadence": "30m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df {t}_basis_pct_15m_df {t}_ohlcv_15m_df",
    "transform": "funding_rate = {t}_funding_rate_30m_df['last'].reindex({t}_ohlcv_15m_df.index, method='ffill'); basis = {t}_basis_pct_15m_df['basis_pct']; price_momentum = {t}_ohlcv_15m_df['close'].pct_change(20); arbitrage_opportunity = (funding_rate.rolling(48).mean() - basis.rolling(96).mean()) * np.sign(price_momentum); arbitrage_strength = arbitrage_opportunity * (abs(funding_rate).rolling(336).rank(pct=True)); arbitrage_strength",
    "output_data_type": "float64",
    "output_data_unit": "arbitrage_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "funding_basis_arbitrage_15m",
    "live_cadence": "30m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df {t}_basis_pct_15m_df {t}_oi_total_15m_df",
    "transform": "funding = {t}_funding_rate_30m_df['last'].reindex({t}_basis_pct_15m_df.index, method='ffill'); basis = {t}_basis_pct_15m_df['basis_pct']; oi = {t}_oi_total_15m_df['oi_total_15m']; arbitrage_spread = funding.rolling(48).mean() - basis.rolling(96).mean(); oi_weight = oi / oi.rolling(168).mean(); arbitrage_opportunity = arbitrage_spread * oi_weight * (abs(arbitrage_spread).rolling(96).rank(pct=True)); funding_arbitrage = arbitrage_opportunity.rolling(20).rank(pct=True); funding_arbitrage",
    "output_data_type": "float64",
    "output_data_unit": "arbitrage_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "funding_rate_30m",
    "live_cadence": "30m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live: 30m Funding Rate (Refer to Unicorn_Wealth_API_Reference_Guide 1.0 CoinAPI)",
    "transform": "parse 'last' to 'funding_rate_30m' df column. All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_funding_rate_30m_df",
    "df_storage_period": 336,
    "df_keys": "timestamp  last",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "funding_rate_cycle_analysis_15m",
    "live_cadence": "30m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df {t}_oi_total_15m_df {t}_ohlcv_15m_df",
    "transform": "funding_rate = {t}_funding_rate_30m_df['last'].reindex({t}_ohlcv_15m_df.index, method='ffill'); oi = {t}_oi_total_15m_df['oi_total_15m']; price = {t}_ohlcv_15m_df['close']; funding_cycle = np.sin(2 * np.pi * funding_rate.rolling(336).rank(pct=True)); oi_momentum = oi.pct_change(24); price_momentum = price.pct_change(24); cycle_alignment = funding_cycle * oi_momentum * price_momentum; funding_cycle_score = cycle_alignment * (abs(funding_rate).rolling(336).rank(pct=True)); funding_cycle_score",
    "output_data_type": "float64",
    "output_data_unit": "cycle_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "funding_rate_momentum_regime_15m",
    "live_cadence": "30m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df {t}_ohlcv_15m_df {t}_oi_total_15m_df",
    "transform": "funding_rate = {t}_funding_rate_30m_df['last'].reindex({t}_ohlcv_15m_df.index, method='ffill'); oi_change = {t}_oi_total_15m_df['oi_total_15m'].pct_change(); price_change = {t}_ohlcv_15m_df['close'].pct_change(); regime_score = np.where((funding_rate > funding_rate.rolling(336).quantile(0.8)) & (oi_change > 0) & (price_change > 0), 2, np.where((funding_rate < funding_rate.rolling(336).quantile(0.2)) & (oi_change < 0) & (price_change < 0), -2, 0)); regime_score",
    "output_data_type": "float64",
    "output_data_unit": "regime_score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "funding_rate_term_slope_8h",
    "live_cadence": "8h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df",
    "transform": "np.polyfit(x=np.arange(16)  y={t}_funding_rate_30m_df['last'].iloc[-16:]  deg=1)[0]",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "funding_rate_zscore_24h",
    "live_cadence": "30m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df",
    "transform": "(lambda s: (s - s.rolling(window=48).mean()) / (s.rolling(window=48).std() + 1e-9))({t}_funding_rate_30m_df['last'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "funding_rate_zscore_7d",
    "live_cadence": "30m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_funding_rate_30m_df",
    "transform": "({t}_funding_rate_30m_df['last'] - {t}_funding_rate_1h_df['last'].rolling(window=336).mean()) / ({t}_funding_rate_30m_df['last'].rolling(window=336).std() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "futures_mark_price_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live: 15m Futures Mark Price (Refer to Unicorn_Wealth_API_Reference_Guide 1.0 CoinAPI)",
    "transform": "parse 'last' to 'futures_mark_price_15m' df column. All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_futures_mark_price_15m_df",
    "df_storage_period": 672,
    "df_keys": "timestamp last",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "futures_oi_trend_strength",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=20).mean()) / (s.rolling(window=20).std() + 1e-9))({t}_oi_total_15m_df['oi_total_15m'].pct_change(periods=5))",
    "output_data_type": "float64",
    "output_data_unit": "dimesnionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fvg_fill_ratio_bear_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bearish FVG\nlast_bearish_fvg = {t}_smc_fvg_15m_df[({t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_15m_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that FVG (creation time  top  and bottom levels)\nfvg_created_time = pd.to_datetime(last_bearish_fvg['smc_fvg_created_time']);\nfvg_top_price = last_bearish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Filter the main price data to find all candles that occurred *after* the FVG was created\ncandles_since_fvg = {t}_ohlcv_15m_df[{t}_ohlcv_15m_df['timestamp'] > fvg_created_time];\n\n# 4. Find the highest high price that has occurred since the FVG was created\nmax_high_since_fvg = candles_since_fvg['high'].max();\n\n# 5. Calculate the final fill ratio\n(fvg_top_price - min(fvg_top_price  max_high_since_fvg)) / (fvg_top_price - fvg_bottom_price)",
    "output_data_type": "float64",
    "output_data_unit": "ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fvg_fill_ratio_bear_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bearish FVG\nlast_bearish_fvg = {t}_smc_fvg_1h_df[({t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bearish') & ({t}_smc_fvg_1h_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that FVG (creation time  top  and bottom levels)\nfvg_created_time = pd.to_datetime(last_bearish_fvg['smc_fvg_created_time']);\nfvg_top_price = last_bearish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_bearish_fvg['smc_fvg_bottom'];\n\n# 3. Filter the main price data to find all candles that occurred *after* the FVG was created\ncandles_since_fvg = {t}_ohlcv_15m_df[{t}_ohlcv_15m_df['timestamp'] > fvg_created_time];\n\n# 4. Find the highest high price that has occurred since the FVG was created\nmax_high_since_fvg = candles_since_fvg['high'].max();\n\n# 5. Calculate the final fill ratio\n(fvg_top_price - min(fvg_top_price  max_high_since_fvg)) / (fvg_top_price - fvg_bottom_price)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fvg_fill_ratio_bull_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bullish FVG\nlast_bullish_fvg = {t}_smc_fvg_15m_df[({t}_smc_fvg_15m_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_15m_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that FVG (creation time  top  and bottom levels)\nfvg_created_time = pd.to_datetime(last_bullish_fvg['smc_fvg_created_time']);\nfvg_top_price = last_bullish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_bullish_fvg['smc_fvg_bottom'];\n\n# 3. Filter the main price data to find all candles that occurred *after* the FVG was created\ncandles_since_fvg = {t}_ohlcv_15m_df[{t}_ohlcv_15m_df['timestamp'] > fvg_created_time];\n\n# 4. Find the lowest low price that has occurred since the FVG was created\nmin_low_since_fvg = candles_since_fvg['low'].min();\n\n# 5. Calculate the final fill ratio\n(max(fvg_bottom_price  min_low_since_fvg) - fvg_bottom_price) / (fvg_top_price - fvg_bottom_price)",
    "output_data_type": "float64",
    "output_data_unit": "ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "fvg_fill_ratio_bull_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_fvg_1h_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent active  bullish FVG\nlast_bullish_fvg = {t}_smc_fvg_1h_df[({t}_smc_fvg_1h_df['smc_fvg_direction'] == 'bullish') & ({t}_smc_fvg_1h_df['smc_fvg_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that FVG (creation time  top  and bottom levels)\nfvg_created_time = pd.to_datetime(last_bullish_fvg['smc_fvg_created_time']);\nfvg_top_price = last_bullish_fvg['smc_fvg_top'];\nfvg_bottom_price = last_bullish_fvg['smc_fvg_bottom'];\n\n# 3. Filter the main price data to find all candles that occurred *after* the FVG was created\ncandles_since_fvg = {t}_ohlcv_15m_df[{t}_ohlcv_15m_df['timestamp'] > fvg_created_time];\n\n# 4. Find the lowest low price that has occurred since the FVG was created\nmin_low_since_fvg = candles_since_fvg['low'].min();\n\n# 5. Calculate the final fill ratio\n(max(fvg_bottom_price  min_low_since_fvg) - fvg_bottom_price) / (fvg_top_price - fvg_bottom_price)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "gas_price_zscore_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "median_fees_usd_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / s.std() if s.std() > 0 else 0.0)(median_fees_usd_df['median_fees_usd_15m'].iloc[-168:])  parse result to gas_price_zscore_1h_df. Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "gas_price_zscore_1h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  gas_price_zscore_1h",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "gas_used_zscore_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "total_gas_used_df",
    "transform": "(lambda s: (s.iloc[-1] - s.mean()) / s.std() if s.std() > 0 else 0.0)(total_gas_used_df['total_gas_used_15m'].iloc[-96:])  gas_used_zscore_4h_df. Most recent value in df to be sent to model for training and live.",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "gas_used_zscore_4h_df",
    "df_storage_period": 2,
    "df_keys": "timestamp  gas_used_zscore_4h",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "gold_close_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get GC=F data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse to 'close' to 'gold_close_15m' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "gold_close_15m_df",
    "df_storage_period": 70,
    "df_keys": "timestamp  gold_close_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "gold_close_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get GC=F data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse to 'close' to 'gold_close_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "gold_close_1d_df",
    "df_storage_period": 70,
    "df_keys": "timestamp  gold_close_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "gold_ema_divergence_21d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": false,
    "transform_data_source": "gold_close_15m_df gold_ema21_1d_df",
    "transform": "(100 * (gold_close_1d_df['gold_close_1d'].iloc[-21:] - gold_ema21_1d_df['gold_ema21_1d'].iloc[-21:]) / gold_ema21_1d_df['gold_ema21_1d'].iloc[-21:]).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "gold_ema21_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "gold_close_1d_df",
    "transform": "ta.trend.EMAIndicator(close  window=21).ema_indicator() adjustable settings to be added to config.py (defaults: Period=21)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "gold_ema21_1d_df",
    "df_storage_period": 21,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "high_low_skew_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(({t}_ohlcv_15m_df['high'] - {t}_ohlcv_15m_df['close']) - ({t}_ohlcv_15m_df['close'] - {t}_ohlcv_15m_df['low'])) / ({t}_ohlcv_15m_df['high'] - {t}_ohlcv_15m_df['low'] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "hour_of_day_cos",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "cos(2pihour_utc/24)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "hour_of_day_sin",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "sin(2pihour_utc/24)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "hurst_exponent_mean_reversion_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "price = {t}_ohlcv_15m_df['close']; log_returns = np.log(price / price.shift(1)); n = 50; lags = range(2, 21); rs_values = []; for lag in lags: segments = [log_returns.iloc[i:i+lag] for i in range(0, len(log_returns)-lag+1, lag)]; rs_lag = []; for segment in segments: if len(segment) == lag and segment.std() > 0: mean_adj = segment - segment.mean(); cum_dev = mean_adj.cumsum(); r = cum_dev.max() - cum_dev.min(); s = segment.std(); rs_lag.append(r/s if s > 0 else 0); rs_values.append(np.mean(rs_lag) if rs_lag else 0); hurst = np.polyfit(np.log(lags), np.log([r for r in rs_values if r > 0] + [1e-9]), 1)[0]; hurst_series = pd.Series([hurst] * len(price), index=price.index); hurst_series",
    "output_data_type": "float64",
    "output_data_unit": "hurst_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "is_price_in_fib_zone_618_786_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_15m_df {t}_ohlcv_15m_df",
    "transform": "int({t}_ohlcv_15m_df['close'].iloc[-1] >= min({t}_fib_retracement_15m_df['0618'].iloc[-1], {t}_fib_retracement_15m_df['0786'].iloc[-1]) and {t}_ohlcv_15m_df['close'].iloc[-1] <= max({t}_fib_retracement_15m_df['0618'].iloc[-1], {t}_fib_retracement_15m_df['0786'].iloc[-1]))",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_price_in_fib_zone_618_786_1d",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_1d_df {t}_ohlcv_15m_df",
    "transform": "int({t}_ohlcv_15m_df['close'].iloc[-1] >= min({t}_fib_retracement_1d_df['0618'].iloc[-1], {t}_fib_retracement_1d_df['0786'].iloc[-1]) and {t}_ohlcv_15m_df['close'].iloc[-1] <= max({t}_fib_retracement_1d_df['0618'].iloc[-1], {t}_fib_retracement_1d_df['0786'].iloc[-1]))",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_price_in_fib_zone_618_786_1h",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_1h_df {t}_ohlcv_15m_df",
    "transform": "int({t}_ohlcv_15m_df['close'].iloc[-1] >= min({t}_fib_retracement_1h_df['0618'].iloc[-1], {t}_fib_retracement_1h_df['0786'].iloc[-1]) and {t}_ohlcv_15m_df['close'].iloc[-1] <= max({t}_fib_retracement_1h_df['0618'].iloc[-1], {t}_fib_retracement_1h_df['0786'].iloc[-1]))",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_price_in_fib_zone_618_786_4h",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fib_retracement_4h_df {t}_ohlcv_15m_df",
    "transform": "int({t}_ohlcv_15m_df['close'].iloc[-1] >= min({t}_fib_retracement_4h_df['0618'].iloc[-1], {t}_fib_retracement_4h_df['0786'].iloc[-1]) and {t}_ohlcv_15m_df['close'].iloc[-1] <= max({t}_fib_retracement_4h_df['0618'].iloc[-1], {t}_fib_retracement_4h_df['0786'].iloc[-1]))",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bearish_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_15m_df  ",
    "transform": "int({t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bearish_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df  ",
    "transform": "int({t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bearish_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df  ",
    "transform": "int({t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bearish_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df  ",
    "transform": "int({t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] < {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bullish_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_15m_df  ",
    "transform": "int({t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_15m_df[{t}_smc_swing_15m_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bullish_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1d_df  ",
    "transform": "int({t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_1d_df[{t}_smc_swing_1d_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bullish_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_1h_df  ",
    "transform": "int({t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_1h_df[{t}_smc_swing_1h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "is_smc_trend_bullish_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_swing_4h_df  ",
    "transform": "int({t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'high']['smc_last_pivot_candidate_level'].iloc[-2] and {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-1] > {t}_smc_swing_4h_df[{t}_smc_swing_4h_df['smc_swing_type'] == 'low']['smc_last_pivot_candidate_level'].iloc[-2])",
    "output_data_type": "int32",
    "output_data_unit": "1 or 0",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "kz_london_flag",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. London kill zone defined as 07 00 to 09 00 UTC inclusive",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "kz_ny_flag",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. New York kill zone defined as 15 00 to 17 00 UTC inclusive",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "Leverage_ratio",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_oi_total_15m_df",
    "transform": "{t}_oi_total_15m_df['oi_total_15m''] / ({t}_ohlcv_15m_df['volume'].replace(0  np.nan))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "liq_notional_zscore_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_long_liq_notional_15m_df {t}_short_liq_notional_15m_df",
    "transform": "(({t}_long_liq_notional_15m_df['longLiqNotional_15m'] + {t}_short_liq_notional_15m_df['shortLiqNotional_15m']) - ({t}_long_liq_notional_15m_df['longLiqNotional_15m'] + {t}_short_liq_notional_15m_df['shortLiqNotional_15m']).rolling(window=192).mean()) / (({t}_long_liq_notional_15m_df['longLiqNotional_15m'] + {t}_short_liq_notional_15m_df['shortLiqNotional_15m']).rolling(window=192).std() + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "liquidations_net_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_long_liq_notional_15m_df {t}_short_liq_notional_15m_df",
    "transform": "(100 * ({t}_long_liq_notional_15m_df['longLiqNotional_15m'].iloc[-1] - {t}_short_liq_notional_15m_df['shortLiqNotional_15m'].iloc[-1])) / ({t}_long_liq_notional_15m_df['longLiqNotional_15m'].iloc[-1] + {t}_short_liq_notional_15m_df['shortLiqNotional_15m'].iloc[-1] + 1e-6)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "liquidity_cascade_risk_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_long_liq_notional_15m_df {t}_short_liq_notional_15m_df {t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "long_liq = {t}_long_liq_notional_15m_df['long_liq_notional']; short_liq = {t}_short_liq_notional_15m_df['short_liq_notional']; price = {t}_ohlcv_15m_df['close']; atr = {t}_atr_15m_df['average_true_range']; liq_imbalance = abs(long_liq - short_liq) / (long_liq + short_liq + 1e-9); price_volatility = atr / price; cascade_risk = liq_imbalance * price_volatility * ((long_liq + short_liq).rolling(20).rank(pct=True)); cascade_risk",
    "output_data_type": "float64",
    "output_data_unit": "risk_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "log_return_1b_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "np.log1p({t}_ohlcv_15m_df['close'].pct_change(periods=1).iloc[-1])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "log_return_1b_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "np.log1p({t}_ohlcv_1h_df['close'].pct_change(periods=1).iloc[-1])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "log_return_5b_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "np.log1p({t}_ohlcv_15m_df['close'].pct_change(periods=5).iloc[-1])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "long_liq_notional_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Liquidations Historical (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "if \"positionType\"=\"LONG\" then compute \"price\"*\"volume\". sum all results for last 15m period and save to dataframe column 'longLiqNotional_15m\".  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_long_liq_notional_15m_df",
    "df_storage_period": 193,
    "df_keys": "timestamp  longLiqNotional_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "lower_wick_pct_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(np.minimum({t}_ohlcv_15m_df['open']  {t}_ohlcv_15m_df['close']) - {t}_ohlcv_15m_df['low']) / ({t}_ohlcv_15m_df['high'] - {t}_ohlcv_15m_df['low'] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.MACD(close  window_fast=30  window_slow=60  window_sign=18)adjustable settings to be added to config.py (defaults: Fast=30  Slow=16  Signal=18)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_macd_15m_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  macd  macd_signal  macd_diff",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.trend.MACD(close  window_fast=30  window_slow=60  window_sign=18)adjustable settings to be added to config.py (defaults: Fast=30  Slow=16  Signal=18)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_macd_1d_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  macd  macd_signal  macd_diff",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.MACD(close  window_fast=30  window_slow=60  window_sign=18)adjustable settings to be added to config.py (defaults: Fast=30  Slow=16  Signal=18)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_macd_1h_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  macd  macd_signal  macd_diff",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.trend.MACD(close  window_fast=30  window_slow=60  window_sign=18)adjustable settings to be added to config.py (defaults: Fast=30  Slow=16  Signal=18)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_macd_4h_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  macd  macd_signal  macd_diff",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_line_pct_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_macd_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))({t}_macd_15m_df['macd'] / ({t}_ohlcv_15m_df['close'] + 1e-9) * 100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_line_pct_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df {t}_macd_1d_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))({t}_macd_1d_df['macd'] / ({t}_ohlcv_1d_df['close'] + 1e-9) * 100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_line_pct_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df {t}_macd_1h_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))({t}_macd_1h_df['macd'] / ({t}_ohlcv_1h_df['close'] + 1e-9) * 100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_line_pct_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df {t}_macd_4h_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))({t}_macd_4h_df['macd'] / ({t}_ohlcv_4h_df['close'] + 1e-9) * 100)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_momentum_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_15m_df",
    "transform": "({t}_macd_15m_df['macd'] - {t}_macd_15m_df['macd'].shift(3)) / (abs({t}_macd_15m_df['macd'].shift(3)) + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_momentum_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_1d_df",
    "transform": "({t}_macd_1d_df['macd'] - {t}_macd_1d_df['macd'].shift(3)) / (abs({t}_macd_1d_df['macd'].shift(3)) + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_momentum_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_1h_df",
    "transform": "({t}_macd_1h_df['macd'] - {t}_macd_1h_df['macd'].shift(3)) / (abs({t}_macd_1h_df['macd'].shift(3)) + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_momentum_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_4h_df",
    "transform": "({t}_macd_4h_df['macd'] - {t}_macd_4h_df['macd'].shift(3)) / (abs({t}_macd_4h_df['macd'].shift(3)) + 1e-9) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_rsi_strength_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_1d_df {t}_rsi_1d_df",
    "transform": "histogram = {t}_macd_1d_df['macd_diff']; macd_signal_strength = abs(histogram) / (abs(histogram).rolling(10).mean() + 1e-9); rsi_volatility = {t}_rsi_1d_df['rsi'].rolling(10).std(); rsi_stability = 1 / (1 + rsi_volatility); (macd_signal_strength * 0.6 + rsi_stability * 0.4)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionsless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_rsi_strength_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_4h_df {t}_rsi_4h_df",
    "transform": "histogram = {t}_macd_4h_df['macd_diff']; macd_signal_strength = abs(histogram) / (abs(histogram).rolling(10).mean() + 1e-9); rsi_volatility = {t}_rsi_4h_df['rsi'].rolling(10).std(); rsi_stability = 1 / (1 + rsi_volatility); (macd_signal_strength * 0.6 + rsi_stability * 0.4)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionsless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "macd_signal_to_line_ratio_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_15m_df",
    "transform": "{t}_macd_15m_df['macd'] / ({t}_macd_15m_df['macd_signal'] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "market_efficiency_ratio_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "price = {t}_ohlcv_15m_df['close']; atr = {t}_atr_15m_df['average_true_range']; direction = abs(price.iloc[-1] - price.shift(20).iloc[-1]); volatility = atr.rolling(20).sum(); efficiency_ratio = direction / (volatility + 1e-9); market_efficiency = pd.Series([efficiency_ratio] * len(price), index=price.index); market_efficiency",
    "output_data_type": "float64",
    "output_data_unit": "efficiency_ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "median_fee_usd_pct_change_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "median_fees_usd_df",
    "transform": "(median_fees_15m_df['median_fees_usd_15m'].pct_change(periods=4).iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "median_fees_usd_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:15m Median Fees USD (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'median_fees_usd_15m' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "median_fees_15m_df",
    "df_storage_period": 168,
    "df_keys": "timestamp  median_fees_usd_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "mfi_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.volume.MFIIndicator(high  low  close  volume  window=50).money_flow_index() adjustable settings to be added to config.py (defaults: Period=50)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_mfi_15m_df",
    "df_storage_period": 673,
    "df_keys": "timestamp  money_flow_index",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "mfi_zscore_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_mfi_15m_df ",
    "transform": "(lambda s: (s - s.rolling(window=672).mean()) / (s.rolling(window=672).std() + 1e-9))({t}_mfi_15m_df['money_flow_index'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "minute_of_hour_cos",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "sin(2piminute_utc/60)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "minute_of_hour_sin",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "cos(2piminute_utc/60)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_alignemnt_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1h_df {t}_ema_mid_1h_df {t}_ema_slow_1h_df",
    "transform": "ema_fast_slope = {t}_ema_fast_1h_df['ema_indicator'].pct_change(1); ema_medium_slope = {t}_ema_mid_1h_df['ema_indicator'].pct_change(1); ema_slow_slope = {t}_ema_slow_1h_df['ema_indicator'].pct_change(1); np.where((ema_fast_slope > 0) & (ema_medium_slope > 0) & (ema_slow_slope > 0)  1  np.where((ema_fast_slope < 0) & (ema_medium_slope < 0) & (ema_slow_slope < 0)  -1  0))",
    "output_data_type": "int32",
    "output_data_unit": " -1 0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_alignment_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df {t}_ema_slow_1d_df",
    "transform": "ema_fast_slope = {t}_ema_fast_1d_df['ema_indicator'].pct_change(1); ema_medium_slope = {t}_ema_mid_1d_df['ema_indicator'].pct_change(1); ema_slow_slope = {t}_ema_slow_1d_df['ema_indicator'].pct_change(1); np.where((ema_fast_slope > 0) & (ema_medium_slope > 0) & (ema_slow_slope > 0)  1  np.where((ema_fast_slope < 0) & (ema_medium_slope < 0) & (ema_slow_slope < 0)  -1  0))",
    "output_data_type": "int32",
    "output_data_unit": " -1 0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_alignment_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_4h_df {t}_ema_mid_4h_df {t}_ema_slow_4h_df",
    "transform": "ema_fast_slope = {t}_ema_fast_4h_df['ema_indicator'].pct_change(1); ema_medium_slope = {t}_ema_mid_4h_df['ema_indicator'].pct_change(1); ema_slow_slope = {t}_ema_slow_4h_df['ema_indicator'].pct_change(1); np.where((ema_fast_slope > 0) & (ema_medium_slope > 0) & (ema_slow_slope > 0)  1  np.where((ema_fast_slope < 0) & (ema_medium_slope < 0) & (ema_slow_slope < 0)  -1  0))",
    "output_data_type": "int32",
    "output_data_unit": " -1 0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "{t}_momentum_alignment_4h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp momentum_alignment",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_clustering_coefficient_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_rsi_15m_df {t}_macd_15m_df",
    "transform": "price_mom = {t}_ohlcv_15m_df['close'].pct_change(5); rsi_mom = {t}_rsi_15m_df['rsi'].diff(5); macd_mom = {t}_macd_15m_df['macd'].diff(5); mom_alignment = (np.sign(price_mom) == np.sign(rsi_mom)).astype(int) + (np.sign(rsi_mom) == np.sign(macd_mom)).astype(int); clustering_coeff = mom_alignment.rolling(20).mean() * abs(price_mom).rolling(20).mean(); momentum_clustering = clustering_coeff * (abs(price_mom).rolling(20).rank(pct=True)); momentum_clustering",
    "output_data_type": "float64",
    "output_data_unit": "clustering_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "momentum_confluence_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_15m_df {t}_rsi_15m_df",
    "transform": "macd_momentum = ({t}_macd_15m_df['macd'] - {t}_macd_15m_df['macd'].shift(3)) / (abs({t}_macd_15m_df['macd'].shift(3)) + 1e-9) * 100; rsi_momentum = {t}_rsi_15m_df['rsi'].diff(3); (np.tanh(macd_momentum / 10) * 0.6 + np.tanh(rsi_momentum / 20) * 0.4)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_momentum_confluence_15m_df",
    "df_storage_period": 1,
    "df_keys": "timeframe momentum_conflucence",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_confluence_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_1d_df {t}_rsi_1d_df",
    "transform": "macd_momentum = ({t}_macd_1d_df['macd'] - {t}_macd_1d_df['macd'].shift(3)) / (abs({t}_macd_1d_df['macd'].shift(3)) + 1e-9) * 100; rsi_momentum = {t}_rsi_1d_df['rsi'].diff(3); (np.tanh(macd_momentum / 10) * 0.6 + np.tanh(rsi_momentum / 20) * 0.4)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_confluence_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_1h_df {t}_rsi_1h_df",
    "transform": "macd_momentum = ({t}_macd_1h_df['macd'] - {t}_macd_1h_df['macd'].shift(3)) / (abs({t}_macd_1h_df['macd'].shift(3)) + 1e-9) * 100; rsi_momentum = {t}_rsi_1h_df['rsi'].diff(3); (np.tanh(macd_momentum / 10) * 0.6 + np.tanh(rsi_momentum / 20) * 0.4)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_confluence_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_4h_df {t}_rsi_4h_df",
    "transform": "macd_momentum = ({t}_macd_4h_df['macd'] - {t}_macd_4h_df['macd'].shift(3)) / (abs({t}_macd_4h_df['macd'].shift(3)) + 1e-9) * 100; rsi_momentum = {t}_rsi_4h_df['rsi'].diff(3); (np.tanh(macd_momentum / 10) * 0.6 + np.tanh(rsi_momentum / 20) * 0.4)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "momentum_decay_feasibility_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "momentum_current = {t}_ohlcv_15m_df['close'].pct_change(5).iloc[-1]; momentum_strength = abs(momentum_current); volatility_current = {t}_ohlcv_15m_df['close'].pct_change().rolling(20).std().iloc[-1]; feasibility_score = np.where(momentum_strength > volatility_current * 2, 1.0, momentum_strength / (volatility_current * 2 + 1e-9))",
    "output_data_type": "float64",
    "output_data_unit": "feasibility_score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "momentum_mean_reversion_regime_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_rsi_15m_df {t}_atr_15m_df",
    "transform": "returns = {t}_ohlcv_15m_df['close'].pct_change(); rsi = {t}_rsi_15m_df['rsi']; volatility = {t}_atr_15m_df['average_true_range'] / {t}_ohlcv_15m_df['close']; momentum_strength = abs(returns.rolling(20).mean()); mean_reversion_signal = np.where(rsi > 70, -1, np.where(rsi < 30, 1, 0)); vol_regime = np.where(volatility > volatility.rolling(50).quantile(0.7), 1, 0); regime_score = momentum_strength * mean_reversion_signal * (1 + vol_regime); momentum_regime = regime_score.rolling(20).rank(pct=True); momentum_regime",
    "output_data_type": "float64",
    "output_data_unit": "regime_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "momentum_persistence_probability_4h_corrected",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "historical_momentum = {t}_ohlcv_15m_df['close'].pct_change(4).rolling(20); historical_returns = {t}_ohlcv_15m_df['close'].pct_change(16).shift(16).rolling(20); rolling_corr = historical_momentum.corrwith(historical_returns, axis=0); persistence_prob = rolling_corr.rolling(50).mean().iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "probability",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "momentum_persistence_score_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['close'].pct_change(periods=1)).rolling(window=20).corr({t}_ohlcv_4h_df['close'].pct_change(periods=1).shift(-1))",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "momentum_volatility_regime_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_momentum_confluence_15m_df, {t}_volatility_regime_4h_df",
    "transform": "abs({t}_momentum_confluence_15m_df['momentum_confluence']) * {t}_volatility_regime_4h_df['volatility_regime']",
    "output_data_type": "float64",
    "output_data_unit": "regime_momentum_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "ms_event_type_n1_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_15m_df  ",
    "transform": "{t}_smc_event_15m_df.iloc[-1]['smc_event_type'] + '_' + {t}_smc_event_15m_df.iloc[-1]['smc_event_direction']",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ms_event_type_n1_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_1d_df  ",
    "transform": "{t}_smc_event_1d_df.iloc[-1]['smc_event_type'] + '_' + {t}_smc_event_1d_df.iloc[-1]['smc_event_direction']",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ms_event_type_n1_1h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_1h_df  ",
    "transform": "{t}_smc_event_1h_df.iloc[-1]['smc_event_type'] + '_' + {t}_smc_event_1h_df.iloc[-1]['smc_event_direction']",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ms_event_type_n1_4h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_event_4h_df",
    "transform": "{t}_smc_event_4h_df.iloc[-1]['smc_event_type'] + '_' + {t}_smc_event_4h_df.iloc[-1]['smc_event_direction']",
    "output_data_type": "string",
    "output_data_unit": "string",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "multi_timeframe_rsi_divergence_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_15m_df {t}_rsi_1h_df {t}_rsi_4h_df {t}_ohlcv_15m_df",
    "transform": "rsi_15m = {t}_rsi_15m_df['rsi']; rsi_1h = {t}_rsi_1h_df['rsi'].reindex({t}_rsi_15m_df.index, method='ffill'); rsi_4h = {t}_rsi_4h_df['rsi'].reindex({t}_rsi_15m_df.index, method='ffill'); price = {t}_ohlcv_15m_df['close']; price_direction = np.sign(price.pct_change(20)); rsi_15m_direction = np.sign(rsi_15m.diff(4)); rsi_1h_direction = np.sign(rsi_1h.diff(4)); rsi_4h_direction = np.sign(rsi_4h.diff(4)); divergence_score = (price_direction != rsi_15m_direction).astype(int) + (rsi_15m_direction != rsi_1h_direction).astype(int) + (rsi_1h_direction != rsi_4h_direction).astype(int); rsi_divergence = divergence_score * abs(price.pct_change(20)); rsi_divergence",
    "output_data_type": "float64",
    "output_data_unit": "divergence_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "mutual_information_btc_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "token_returns = {t}_ohlcv_15m_df['close'].pct_change(); btc_returns = btc_ohlcv_15m_df['close'].pct_change(); token_bins = pd.cut(token_returns.dropna(), bins=5, labels=False); btc_bins = pd.cut(btc_returns.dropna(), bins=5, labels=False); joint_prob = pd.crosstab(token_bins, btc_bins, normalize=True); token_prob = joint_prob.sum(axis=1); btc_prob = joint_prob.sum(axis=0); mi = 0; for i in range(5): for j in range(5): if joint_prob.iloc[i,j] > 0: mi += joint_prob.iloc[i,j] * np.log(joint_prob.iloc[i,j] / (token_prob.iloc[i] * btc_prob.iloc[j] + 1e-9)); mutual_info = pd.Series([mi] * len(token_returns), index=token_returns.index); mutual_info",
    "output_data_type": "float64",
    "output_data_unit": "mi_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "mvrv_long_short_diff_usd_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live: 1d MVRV Long Short Differential (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse'value' to 'mvrv_long_short_diff_usd_1d' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_mvrv_long_short_diff_usd_df",
    "df_storage_period": 91,
    "df_keys": "timestamp  mvrv_long_short_diff_usd_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "mvrv_long_short_diff_usd_zscore_90d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_mvrv_long_short_diff_usd_df",
    "transform": "(lambda s: (s - s.rolling(window=90).mean()) / (s.rolling(window=90).std() + 1e-9))({t}_mvrv_long_short_diff_usd_df['mvrv_long_short_diff_usd_1d'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "network_activity_momentum_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_active_addresses_24h_df {t}_transaction_volume_usd_1d_df {t}_fees_usd_intraday_15m_df",
    "transform": "addresses = {t}_active_addresses_24h_df['active_addresses_24h']; tx_volume = {t}_transaction_volume_usd_1d_df['transaction_volume_usd'].reindex({t}_active_addresses_24h_df.index, method='ffill'); fees = {t}_fees_usd_intraday_15m_df['fees_usd']; network_activity = (addresses.pct_change(7) + tx_volume.pct_change(7)) / 2; fee_momentum = fees.pct_change(20); activity_momentum = network_activity * fee_momentum * (addresses.rolling(30).rank(pct=True)); network_momentum = activity_momentum.rolling(20).rank(pct=True); network_momentum",
    "output_data_type": "float64",
    "output_data_unit": "network_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "network_activity_zscore_24h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_active_addresses_24h_df",
    "transform": "(lambda s: (s - s.rolling(window=30).mean()) / (s.rolling(window=30).std() + 1e-9))({t}_active_addresses_24h_df['active_addresses_24h'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "network_congestion_arbitrage_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fees_usd_intraday_15m_df {t}_active_addresses_24h_df {t}_ohlcv_15m_df",
    "transform": "fees = {t}_fees_usd_intraday_15m_df['fees_usd']; addresses = {t}_active_addresses_24h_df['active_addresses_24h']; price = {t}_ohlcv_15m_df['close']; congestion_ratio = fees / (addresses + 1e-9); congestion_premium = congestion_ratio.rolling(96).rank(pct=True); price_sensitivity = price.pct_change().rolling(20).corr(congestion_ratio.pct_change()); arbitrage_signal = congestion_premium * price_sensitivity * (fees.rolling(96).rank(pct=True)); congestion_arbitrage = arbitrage_signal.rolling(20).rank(pct=True); congestion_arbitrage",
    "output_data_type": "float64",
    "output_data_unit": "congestion_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "network_congestion_price_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_fees_usd_intraday_15m_df {t}_active_addresses_24h_df {t}_ohlcv_15m_df",
    "transform": "fees = {t}_fees_usd_intraday_15m_df['fees_usd']; addresses = {t}_active_addresses_24h_df['active_addresses_24h']; price = {t}_ohlcv_15m_df['close']; congestion_ratio = fees / (addresses + 1e-9); price_sensitivity = price.pct_change().rolling(20).corr(congestion_ratio.pct_change()); network_pressure = congestion_ratio.rolling(20).rank(pct=True) * price_sensitivity; network_pressure",
    "output_data_type": "float64",
    "output_data_unit": "pressure_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "network_profit_loss_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live: 1d Network Profit Loss (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment)",
    "transform": "parse 'value' to 'network_profit_loss_1d' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_network_profit_loss_1d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  network_profit_loss_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "WARNING"
  },
  {
    "operation": "network_value_momentum_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_network_profit_loss_1d_df {t}_transaction_volume_usd_1d_df {t}_ohlcv_15m_df",
    "transform": "network_pnl = {t}_network_profit_loss_1d_df['network_profit_loss'].reindex({t}_ohlcv_15m_df.index, method='ffill'); tx_volume = {t}_transaction_volume_usd_1d_df['transaction_volume_usd'].reindex({t}_ohlcv_15m_df.index, method='ffill'); price = {t}_ohlcv_15m_df['close']; network_efficiency = network_pnl / (tx_volume + 1e-9); value_momentum = network_efficiency.pct_change(7) * price.pct_change(20); momentum_strength = value_momentum * (network_efficiency.rolling(30).rank(pct=True)); momentum_strength",
    "output_data_type": "float64",
    "output_data_unit": "momentum_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "WARNING"
  },
  {
    "operation": "ob_strength_bear_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_vol_sma_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the exact creation timestamp of that Order Block\nob_created_time = pd.to_datetime(last_active_bear_ob['smc_ob_created_time']);\n\n# 3. Find the specific OHLCV candle that corresponds to the OB's creation time\nob_candle = {t}_ohlcv_15m_df[{t}_ohlcv_15m_df['timestamp'] == ob_created_time];\n\n# 4. Get the volume from that specific candle\nob_volume_n1 = ob_candle['volume'].iloc[0];\n\n# 5. Find the corresponding SMA of the volume at the time the OB was created\nsma_at_ob_creation = {t}_vol_sma_15m_df[{t}_vol_sma_15m_df['timestamp'] == ob_created_time]['volume_sma'].iloc[0];\n\n# 6. Calculate the final strength ratio\nob_volume_n1 / (sma_at_ob_creation + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ob_strength_bear_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_vol_sma_1h_df {t}_ohlcv_1h_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the exact creation timestamp of that Order Block\nob_created_time = pd.to_datetime(last_active_bear_ob['smc_ob_created_time']);\n\n# 3. Find the specific OHLCV candle that corresponds to the OB's creation time\nob_candle = {t}_ohlcv_1h_df[{t}_ohlcv_1h_df['timestamp'] == ob_created_time];\n\n# 4. Get the volume from that specific candle\nob_volume_n1 = ob_candle['volume'].iloc[0];\n\n# 5. Find the corresponding SMA of the volume at the time the OB was created\nsma_at_ob_creation = {t}_vol_sma_1h_df[{t}_vol_sma_1h_df['timestamp'] == ob_created_time]['volume_sma'].iloc[0];\n\n# 6. Calculate the final strength ratio\nob_volume_n1 / (sma_at_ob_creation + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ob_strength_bull_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_vol_sma_15m_df {t}_ohlcv_15m_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the exact creation timestamp of that Order Block\nob_created_time = pd.to_datetime(last_active_bull_ob['smc_ob_created_time']);\n\n# 3. Find the specific OHLCV candle that corresponds to the OB's creation time\nob_candle = {t}_ohlcv_15m_df[{t}_ohlcv_15m_df['timestamp'] == ob_created_time];\n\n# 4. Get the volume from that specific candle\nob_volume_n1 = ob_candle['volume'].iloc[0];\n\n# 5. Find the corresponding SMA of the volume at the time the OB was created\nsma_at_ob_creation = {t}_vol_sma_15m_df[{t}_vol_sma_15m_df['timestamp'] == ob_created_time]['volume_sma'].iloc[0];\n\n# 6. Calculate the final strength ratio\nob_volume_n1 / (sma_at_ob_creation + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ob_strength_bull_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_vol_sma_1h_df {t}_ohlcv_1h_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the exact creation timestamp of that Order Block\nob_created_time = pd.to_datetime(last_active_bull_ob['smc_ob_created_time']);\n\n# 3. Find the specific OHLCV candle that corresponds to the OB's creation time\nob_candle = {t}_ohlcv_1h_df[{t}_ohlcv_1h_df['timestamp'] == ob_created_time];\n\n# 4. Get the volume from that specific candle\nob_volume_n1 = ob_candle['volume'].iloc[0];\n\n# 5. Find the corresponding SMA of the volume at the time the OB was created\nsma_at_ob_creation = {t}_vol_sma_1h_df[{t}_vol_sma_1h_df['timestamp'] == ob_created_time]['volume_sma'].iloc[0];\n\n# 6. Calculate the final strength ratio\nob_volume_n1 / (sma_at_ob_creation + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "ob_width_pct_bear_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_atr_15m_df",
    "transform": "# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that Order Block\nob_created_time = pd.to_datetime(last_active_bear_ob['smc_ob_created_time']);\nob_high_price_n1 = last_active_bear_ob['smc_ob_top'];\nob_low_price_n1 = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Find the corresponding ATR value at the time the OB was created\natr_at_ob_creation = {t}_atr_15m_df[{t}_atr_15m_df['timestamp'] == ob_created_time]['average_true_range'].iloc[0];\n\n# 4. Calculate the final width percentage\n((ob_high_price_n1 - ob_low_price_n1) / (atr_at_ob_creation + 1e-9)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ob_width_pct_bear_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df {t}_atr_1h_df",
    "transform": "\"# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that Order Block\nob_created_time = pd.to_datetime(last_active_bear_ob['smc_ob_created_time']);\nob_high_price_n1 = last_active_bear_ob['smc_ob_top'];\nob_low_price_n1 = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Find the corresponding ATR value at the time the OB was created\natr_at_ob_creation = {t}_atr_1h_df[{t}_atr_1h_df['timestamp'] == ob_created_time]['average_true_range].iloc[0];\n\n# 4. Calculate the final width percentage\n((ob_high_price_n1 - ob_low_price_n1) / (atr_at_ob_creation + 1e-9)) * 100\"",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ob_width_pct_bear_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_4h_df  {t}_atr_4h_df",
    "transform": "\"# 1. Find the most recent *active*  bearish Order Block\nlast_active_bear_ob = {t}_smc_ob_4h_df[({t}_smc_ob_4h_df['smc_ob_direction'] == 'bearish') & ({t}_smc_ob_4h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that Order Block\nob_created_time = pd.to_datetime(last_active_bear_ob['smc_ob_created_time']);\nob_high_price_n1 = last_active_bear_ob['smc_ob_top'];\nob_low_price_n1 = last_active_bear_ob['smc_ob_bottom'];\n\n# 3. Find the corresponding ATR value at the time the OB was created\natr_at_ob_creation = {t}_atr_4h_df[{t}_atr_4h_df['timestamp'] == ob_created_time]['average_true_range'].iloc[0];\n\n# 4. Calculate the final width percentage\n((ob_high_price_n1 - ob_low_price_n1) / (atr_at_ob_creation + 1e-9)) * 100\"",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ob_width_pct_bull_15m_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_15m_df {t}_atr_15m_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_15m_df[({t}_smc_ob_15m_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_15m_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that Order Block\nob_created_time = pd.to_datetime(last_active_bull_ob['smc_ob_created_time']);\nob_high_price_n1 = last_active_bull_ob['smc_ob_top'];\nob_low_price_n1 = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Find the corresponding ATR value at the time the OB was created\natr_at_ob_creation = {t}_atr_15m_df[{t}_atr_15m_df['timestamp'] == ob_created_time]['average_true_range'].iloc[0];\n\n# 4. Calculate the final width percentage\n((ob_high_price_n1 - ob_low_price_n1) / (atr_at_ob_creation + 1e-9)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ob_width_pct_bull_1h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_1h_df  {t}_atr_1h_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_1h_df[({t}_smc_ob_1h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_1h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that Order Block\nob_created_time = pd.to_datetime(last_active_bull_ob['smc_ob_created_time']);\nob_high_price_n1 = last_active_bull_ob['smc_ob_top'];\nob_low_price_n1 = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Find the corresponding ATR value at the time the OB was created\natr_at_ob_creation = {t}_atr_1h_df[{t}_atr_1h_df['timestamp'] == ob_created_time]['average_true_range'].iloc[0];\n\n# 4. Calculate the final width percentage\n((ob_high_price_n1 - ob_low_price_n1) / (atr_at_ob_creation + 1e-9)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ob_width_pct_bull_4h_swing",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_ob_4h_df  {t}_atr_4h_df",
    "transform": "# 1. Find the most recent *active*  bullish Order Block\nlast_active_bull_ob = {t}_smc_ob_4h_df[({t}_smc_ob_4h_df['smc_ob_direction'] == 'bullish') & ({t}_smc_ob_4h_df['smc_ob_status'] == 'active')].iloc[-1];\n\n# 2. Get the properties of that Order Block\nob_created_time = pd.to_datetime(last_active_bull_ob['smc_ob_created_time']);\nob_high_price_n1 = last_active_bull_ob['smc_ob_top'];\nob_low_price_n1 = last_active_bull_ob['smc_ob_bottom'];\n\n# 3. Find the corresponding ATR value at the time the OB was created\natr_at_ob_creation = {t}_atr_4h_df[{t}_atr_4h_df['timestamp'] == ob_created_time]['average_true_range'].iloc[0];\n\n# 4. Calculate the final width percentage\n((ob_high_price_n1 - ob_low_price_n1) / (atr_at_ob_creation + 1e-9)) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "obv_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.volume.OnBalanceVolumeIndicator(close  volume).on_balance_volume()  adjustable settings to be added to config.py (defaults: Signal Line=SMA60)",
    "output_data_type": "float64",
    "output_data_unit": "volume units",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_obv_15m_df",
    "df_storage_period": 673,
    "df_keys": "timestamp  on_balance_volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "obv_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.volume.OnBalanceVolumeIndicator(close  volume).on_balance_volume() adjustable settings to be added to config.py (defaults: Signal Line=SMA60)",
    "output_data_type": "float64",
    "output_data_unit": "volume units",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_obv_1h_df",
    "df_storage_period": 169,
    "df_keys": "timestamp  on_balance_volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "obv_zscore_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_obv_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=672).mean()) / (s.rolling(window=672).std() + 1e-9))({t}_obv_15m_df['on_balance_volume'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "obv_zscore_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_obv_1h_df",
    "transform": "(lambda s: (s - s.rolling(window=168).mean()) / (s.rolling(window=168).std() + 1e-9))({t}_obv_1h_df['on_balance_volume'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1m_df",
    "transform": "aggregate 15m OHLCV values from {t}_ohlcv_1m_df and save to {t}_ohlcv_15m_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ohlcv_15m_df",
    "df_storage_period": 2880,
    "df_keys": "timestamp open  high  low  close  volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_15m_historical",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical Only: 15m Spot OHLCV (Refer to Unicorn_Wealth_API_Reference Guide:1.0 CoinAPI) ",
    "transform": "parse timestamp open high low close volume and save to postgres database for training.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "multiple",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": false,
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "aggregate 1d OHLCV values from {t}_ohlcv_4h_df and save to {t}_ohlcv_1d_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ohlcv_1d_df",
    "df_storage_period": 730,
    "df_keys": "timestamp open  high  low  close  volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_1d_historical",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical Only: 1d  Spot OHLCV (Refer to Unicorn_Wealth_API_Reference Guide: 1.0 CoinAPI) ",
    "transform": "parse timestamp open high low close volume and save to postgres database for training.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "multiple",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": false,
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "aggregate 1h OHLCV values from {t}_ohlcv_15m_df and save to {t}_ohlcv_1h_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ohlcv_1h_df",
    "df_storage_period": 1440,
    "df_keys": "timestamp open  high  low  close  volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_1h_historical",
    "live_cadence": "1h",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical Only: 1h  Spot OHLCV (Refer to Unicorn_Wealth_API_Reference Guide: 1.0 CoinAPI) ",
    "transform": "parse timestamp open high low close volume and save to postgres database for training.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "multiple",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": false,
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_1m",
    "live_cadence": "Websocket",
    "step_order": 0,
    "calculate_per_token": true,
    "transform_data_source": "Live Only: Websocket stream of Spot OHLCV. Refer to Unicorn_Wealth_Websocket_Reference Guide)",
    "transform": "aggregate websocket stream into 1m OHLCV data and parse 'open'  'high'  'low'  'close'  'volume' to corresponding df columns",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ohlcv_1m_df",
    "df_storage_period": 800,
    "df_keys": "timestamp  open  high  low  close  volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 0,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "aggregate 4h OHLCV values from {t}_ohlcv_1h_df and save to {t}_ohlcv_4h_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ohlcv_4h_df",
    "df_storage_period": 1080,
    "df_keys": "timestamp open  high  low  close  volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_4h_historical",
    "live_cadence": "4h",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical Only: 4h  Spot OHLCV (Refer to Unicorn_Wealth_API_Reference Guide: 1.0 CoinAPI)",
    "transform": "parse timestamp open high low close volume and save to postgres database for training .  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "multiple",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": false,
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_7d",
    "live_cadence": "7d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "aggregate 7d OHLCV values from {t}_ohlcv_1d_df and save to {t}_ohlcv_7d_df",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_ohlcv_7d_df",
    "df_storage_period": 52,
    "df_keys": "timestamp open  high  low  close  volume",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ohlcv_7d_historical",
    "live_cadence": "7d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical Only: 7d  Spot OHLCV (Refer to Unicorn_Wealth_API_Reference Guide: 1.0 CoinAPI) ",
    "transform": "parse timestamp open high low close volume and save to postgres database for training.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data).",
    "output_data_type": "float64",
    "output_data_unit": "multiple",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": false,
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "oi_pct_change",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df",
    "transform": "{t}_oi_total_15m_df['oi_total_15m'].pct_change()  parse result to {t}_oi_pct_change_15m_df dataframe",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "timestamp  oi_pct_change",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "oi_pct_change_24h",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df",
    "transform": "{t}_oi_total_15m_df['oi_total_15m'].pct_change(periods=96).iloc[-1] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "oi_spike_event",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_pct_change_15m",
    "transform": "({t}_oi_pct_change_15m['oi_pct_change'] > (3 * {t}_oi_pct_change_15m['oi_pct_change'].rolling(window=96).std())).astype(int)",
    "output_data_type": "int32",
    "output_data_unit": "0 or 1",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "oi_to_volume_ratio_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df {t}_ohlcv_15m_df",
    "transform": "{t}_oi_total_15m_df['oi_total_15m'] / ({t}_ohlcv_15m_df['volume'] + 1e-6)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "oi_total_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Exchange Open Interest (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment",
    "transform": "parse \"value\" to \"oi_total_15m\" df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_oi_total_15m_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  oi_total_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "oi_trend_strengh",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_oi_total_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=20).mean()) / (s.rolling(window=20).std() + 1e-9))({t}_oi_total_15m_df['oi_total_15m'].pct_change(periods=5))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "parkinson_volatility_15",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.volatility.parkinson({t}_ohlcv_15m_df['high']  {t}_ohlcv_15m_df['low']  window=15)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "pca_correlation_regime_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df eth_ohlcv_15m_df {t}_close_spx_15m_df",
    "transform": "token_ret = {t}_ohlcv_15m_df['close'].pct_change(); btc_ret = btc_ohlcv_15m_df['close'].pct_change(); eth_ret = eth_ohlcv_15m_df['close'].pct_change(); spx_ret = {t}_close_spx_15m_df['close'].pct_change(); corr_matrix = pd.concat([token_ret, btc_ret, eth_ret, spx_ret], axis=1).rolling(96).corr(); eigenvals = []; for i in range(len(corr_matrix)): if i >= 95: matrix = corr_matrix.iloc[i-95:i+1].values.reshape(4,4); if not np.isnan(matrix).any(): eigs = np.linalg.eigvals(matrix); eigenvals.append(eigs[0]); else: eigenvals.append(np.nan); else: eigenvals.append(np.nan); pca_regime = pd.Series(eigenvals, index=token_ret.index); pca_regime",
    "output_data_type": "float64",
    "output_data_unit": "pca_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "percent_of_total_supply_on_exchanges_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:1d Percent of Total Supply on Exchanges (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment)",
    "transform": "parse 'value' to 'percent_of_total_supply_on_exchanges_1d' df column. All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_percent_of_total_supply_on_exchanges_1d_df",
    "df_storage_period": 91,
    "df_keys": "timestamp  percent_of_total_supply_on_exchanges_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "percent_supply_exchg_7d_avg",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_percent_of_total_supply_on_exchanges_1d_df",
    "transform": "{t}_percent_of_total_supply_on_exchanges_1d_df['percent_of_total_supply_on_exchanges_1d'].iloc[-7:].mean()",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "perp_close_1h",
    "live_cadence": "1h",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:1h Perpetual Close (from Futures OHLCV) (Refer to Unicorn_Wealth_API_Reference Guide: 1.0 CoinAPI)",
    "transform": "parse 'price_close' to 'perpClose_1h' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_perp_close_1h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  perpClose_1h",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "pivot_points_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "requires custom implementation for detection of Daily pivot points using Traditional method. Required values to parse are 'R1'  'S1' & 'Pivot' to df columns",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_pivot_points_1d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp r1 s1 pivot",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "pivot_points_7d",
    "live_cadence": "7d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_7d_df",
    "transform": "requires custom implementation for detection of Weekly pivot points using Traditional method. Required values to parse are 'R1'  'S1' & 'Pivot' to df columns",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_pivot_points_7d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp r1 s1 pivot",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "pressure_momentum_alignment_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_pressure_momentum_5bp_15min_df, {t}_momentum_alignment_4h_df",
    "transform": "abs({t}_pressure_momentum_5bp_15min_df['pressure_momentum_5bp']) * abs({t}_momentum_alignment_4h)",
    "output_data_type": "float64",
    "output_data_unit": "alignment_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "price_oi_div",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_oi_pct_change_15m",
    "transform": "np.sign({t}_ohlcv_15m_df['close'].pct_change(periods=1)) * np.sign({t}_oi_pct_change_15m['oi_pct_change'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "price_position_in_trend_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ema_fast_15m_df {t}_ema_mid_15m_df {t}_ema_slow_15m_df",
    "transform": "ema_min = np.minimum(np.minimum({t}_ema_fast_15m_df['ema_indicator']  {t}_ema_mid_15m_df['ema_indicator'])  {t}_ema_slow_15m_df['ema_indicator']); ema_max = np.maximum(np.maximum({t}_ema_fast_15m_df['ema_indicator']  {t}_ema_mid_15m_df['ema_indicator'])  {t}_ema_slow_15m_df['ema_indicator']); ({t}_ohlcv_15m_df['close'] - ema_min) / (ema_max - ema_min)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "price_position_in_trend_1d",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ema_fast_1d_df {t}_ema_mid_1d_df {t}_ema_slow_1d_df {t}_ohlcv_15m_df",
    "transform": "ema_min = np.minimum(np.minimum({t}_ema_fast_1d_df['ema_indicator']  {t}_ema_mid_1d_df['ema_indicator'])  {t}_ema_slow_1d_df['ema_indicator']); ema_max = np.maximum(np.maximum({t}_ema_fast_1d_df['ema_indicator']  {t}_ema_mid_1d_df['ema_indicator'])  {t}_ema_slow_1d_df['ema_indicator']); ({t}_ohlcv_15m_df['close'] - ema_min) / (ema_max - ema_min)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "realised_vol_30b",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "np.log1p({t}_ohlcv_15m_df['close'].pct_change()).iloc[-30:].std()",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "regime_detection_hmm_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df {t}_rsi_15m_df",
    "transform": "returns = {t}_ohlcv_15m_df['close'].pct_change(); vol = {t}_atr_15m_df['average_true_range'] / {t}_ohlcv_15m_df['close']; rsi = {t}_rsi_15m_df['rsi']; regime_score = np.where((vol.rolling(20).mean() > vol.rolling(50).mean()) & (abs(returns.rolling(20).mean()) > returns.rolling(50).std()), 2, np.where((vol.rolling(20).mean() < vol.rolling(50).mean()) & (abs(returns.rolling(20).mean()) < returns.rolling(50).std()), 0, 1)); regime_score",
    "output_data_type": "float64",
    "output_data_unit": "regime_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rolling_volatility_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_futures_mark_price_15m_df",
    "transform": "np.log1p({t}_futures_mark_price_15m_df['last'].pct_change()).iloc[-100:].std()",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rs_vs_btc_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df {t}_btc_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['close'].pct_change(periods=1).iloc[-1]) / ({t}_btc_ohlcv_1d_df['close'].pct_change(periods=1).iloc[-1] + 1e-9) - 1",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.momentum.RSIIndicator(close  window=40).rsi() adjustable settings to be added to config.py (defaults: Period=40)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_rsi_15m_df",
    "df_storage_period": 673,
    "df_keys": "timestamp  rsi",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.momentum.RSIIndicator(close  window=40).rsi() adjustable settings to be added to config.py (defaults: Period=40)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_rsi_1d_df",
    "df_storage_period": 11,
    "df_keys": "timestamp  rsi",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.momentum.RSIIndicator(close  window=40).rsi() adjustable settings to be added to config.py (defaults: Period=40)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_rsi_1h_df",
    "df_storage_period": 169,
    "df_keys": "timestamp  rsi",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.momentum.RSIIndicator(close  window=40).rsi() adjustable settings to be added to config.py (defaults: Period=40)",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_rsi_4h_df",
    "df_storage_period": 43,
    "df_keys": "timestamp  rsi",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_extreme_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_15m_df",
    "transform": "np.where({t}_rsi_15m_df['rsi'] > 80  -1  np.where({t}_rsi_15m_df['rsi'] < 20  1  0))",
    "output_data_type": "int32",
    "output_data_unit": "ternery signal",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_momentum_persistence_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "rsi_current = ta.momentum.RSIIndicator({t}_ohlcv_15m_df['close'], window=14).rsi().iloc[-1]; rsi_change = ta.momentum.RSIIndicator({t}_ohlcv_15m_df['close'], window=14).rsi().diff(4).iloc[-1]; momentum_score = {t}_ohlcv_15m_df['close'].pct_change(4).iloc[-1]; persistence_score = np.where(abs(rsi_change) > 5 and abs(momentum_score) > 0.01, abs(rsi_change) * abs(momentum_score) * 100, 0)",
    "output_data_type": "float64",
    "output_data_unit": "persistence_score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_signal_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_1h_df",
    "transform": "np.where({t}_rsi_1h_df['rsi'] > 70  -1  np.where({t}_rsi_1h_df['rsi'] < 30  1  0))",
    "output_data_type": "int32",
    "output_data_unit": "ternery signal",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_slope_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_15m_df ",
    "transform": "np.polyfit(x=np.arange(15)  y={t}_rsi_15m_df['rsi'].iloc[-15:]  deg=1)[0]",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_volume_strength_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_zscore_15m_df, {t}_volume_zscore_20_15m_df",
    "transform": "abs({t}_rsi_zscore_15m_df['rsi_zscore']) *{t}_volume_zscore_20_15m_df['volume_zscore_20']",
    "output_data_type": "float64",
    "output_data_unit": "strength_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_zscore_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=672).mean()) / (s.rolling(window=672).std() + 1e-9))({t}_rsi_15m_df['rsi'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_rsi_zscore_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp rsi_zscore",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_zscore_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_1h_df",
    "transform": "(lambda s: (s - s.rolling(window=168).mean()) / (s.rolling(window=168).std() + 1e-9))({t}_rsi_1h_df['rsi'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "rsi_zscore_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_rsi_4h_df",
    "transform": "(lambda s: (s - s.rolling(window=42).mean()) / (s.rolling(window=42).std() + 1e-9))({t}_rsi_4h_df['rsi'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "sentiment_weighted_total_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Sentiment Weighted Total (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'sentiment_weighted_total_15m' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "sentiment score",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_sentiment_weighted_total_15m_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  sentiment_weighted_total_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "sentiment_weighted_zscore_24h",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_sentiment_weighted_total_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))({t}_sentiment_weighted_total_15m_df['sentiment_weighted_total_15m'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "sess_asia_flag",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. Asia session defined as 23 00 to 07 00 UTC inclusive",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "sess_london_flag",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. London session defined as 07 00 to 15 00 UTC inclusive",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "sess_ny_flag",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "not applicable",
    "transform": "use existing sessions.py for calculations. New York session defined as 15 00 to 23 00 UTC inclusive",
    "output_data_type": "boolean",
    "output_data_unit": "TRUE or FALSE",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "short_liq_notional_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Liquidations Historical (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "if \"positionType\"=\"SHORT\" then compute \"price\"*\"volume\". sum all results for last 15m period and save to dataframe column 'shortLiqNotional_15m\".  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_short_liq_notional_15m_df",
    "df_storage_period": 193,
    "df_keys": "timestamp  shortLiqNotional_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "smart_money_divergence_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_15m_df {t}_ohlcv_15m_df {t}_social_dominance_total_15m_df",
    "transform": "smc_signal = {t}_smc_15m_df['smc_signal']; price_action = {t}_ohlcv_15m_df['close'].pct_change(); social_sentiment = {t}_social_dominance_total_15m_df['social_dominance']; smart_money_direction = np.sign(smc_signal.rolling(20).mean()); retail_direction = np.sign(social_sentiment.rolling(20).mean()); divergence_score = (smart_money_direction - retail_direction) * abs(price_action.rolling(20).mean()); divergence_score",
    "output_data_type": "float64",
    "output_data_unit": "divergence_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "smart_money_flow_divergence_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_smc_15m_df {t}_whale_transaction_volume_1m_usd_to_inf_df {t}_social_dominance_total_15m_df",
    "transform": "smc_signal = {t}_smc_15m_df['smc_signal']; whale_flow = {t}_whale_transaction_volume_1m_usd_to_inf_df['whale_transaction_volume']; social_flow = {t}_social_dominance_total_15m_df['social_dominance']; smart_momentum = smc_signal.rolling(20).mean() + whale_flow.pct_change(20); retail_momentum = social_flow.pct_change(20); flow_divergence = (smart_momentum - retail_momentum) / (abs(smart_momentum) + abs(retail_momentum) + 1e-9); divergence_strength = flow_divergence * (abs(smart_momentum).rolling(20).rank(pct=True)); smart_divergence = divergence_strength.rolling(20).rank(pct=True); smart_divergence",
    "output_data_type": "float64",
    "output_data_unit": "flow_divergence_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "smc_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "run smc.py with 15m swing settings on the OHLCV data contained within {t}_ohlcv_15m. Results to be mapped and saved to separate dataframes with columns as defined in this row of data. adjustable settings to be added to config.py (defaults: Swing=30)",
    "output_data_type": "multiple",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_smc_swing_15m_df  {t}_smc_event_15m_df  {t}_smc_fvg_15m_df  {t}_smc_ob_15m_df  {t}_smc_pd_15m_df",
    "df_storage_period": "as required to store all returned data",
    "df_keys": "REQUIRED COLUMNS FOR EACH SMC DATAFRAME: ({t}_smc_swing_15m_df = smc_swing_id (string  unique code)  smc_swing_confirmation_time (UNIX)  smc_swing_type (string  high or low)  smc_swing_strong (string  strong or weak)  smc_swing_interval (string)  smc_swing_pivot_time (UNIX)  smc_last_pivot_candidate_time (UNIX)  smc_last_pivot_candidate_level (float64 USD)  smc_last_pivot_candidate_type (string  high or low))  ({t}_smc_event_15m_df = smc_event_id (string  unique code)  smc_event_created (UNIX)  smc_event_type (string  BOS or CHOCH)  smc_event_direction (string  bullish or bearish)  smc_event_interval (string)  smc_event_price (float64 USD)  smc_event_break_time (UNIX)  smc_event_swing_point (UNIX))  ({t}_smc_fvg_15m_df = smc_fvg_id (string  unique code)  smc_fvg_created_time (UNIX)  smc_fvg_direction (string  bullish or bearish)  smc_fvg_interval (string)  smc_fvg_bottom(float64 USD)  smc_fvg_top(float64 USD)  smc_fvg_status (string  active or mitigated)  smc_fvg_mitigated_time(UNIX)  smc_fvg_size(float64 %)  smc_fvg_left_time (UNIX))  ({t}_smc_ob_15m_df = smc_ob_id  smc_ob_created_time(UNIX)  smc_ob_direction(string  bullish or bearish)  smc_ob_interval(string)  smc_ob_top(float64 USD)  smc_ob_bottom(float64 USD)  smc_ob_status(string  active or mitigated)  smc_ob_mitigated_time(UNIX)  smc_ob_strength(float64 %)  smc_ob_size(float64 %)  smc_ob_left_time(UNIX))  ({t}_smc_pd_15m = smc_premium_top(float64 USD)  smc_premium_bottom(float64 USD)  smc_equilibrium_top(float64 USD)  smc_equilibrium_bottom(float64 USD)  smc_discount_top(float64 USD)  smc_discount_bottom(float64 USD)  smc_trailing_top(float64 USD)  smc_trailing_bottom(float64 USD)  smc_trailing_top_time(UNIX)  smc_trailing_bottom_time(UNIX))",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "smc_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "run smc.py with 1d swing settings on the OHLCV data contained within {t}_ohlcv_1d. Results to be mapped and saved to separate dataframes with columns as defined in this row of data.  adjustable settings to be added to config.py (defaults: Swing=25)",
    "output_data_type": "multiple",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_smc_swing_1d_df  {t}_smc_event_1d_df  {t}_smc_fvg_1d_df  {t}_smc_ob_1d_df  {t}_smc_pd_1d_df",
    "df_storage_period": "as required to store all returned data",
    "df_keys": "REQUIRED COLUMNS FOR EACH SMC DATAFRAME: ({t}_smc_swing_1d_df = smc_swing_id (string  unique code)  smc_swing_confirmation_time (UNIX)  smc_swing_type (string  high or low)  smc_swing_strong (string  strong or weak)  smc_swing_interval (string)  smc_swing_pivot_time (UNIX)  smc_last_pivot_candidate_time (UNIX)  smc_last_pivot_candidate_level (float64 USD)  smc_last_pivot_candidate_type (string  high or low))  ({t}_smc_event_1d_df = smc_event_id (string  unique code)  smc_event_created (UNIX)  smc_event_type (string  BOS or CHOCH)  smc_event_direction (string  bullish or bearish)  smc_event_interval (string)  smc_event_price (float64 USD)  smc_event_break_time (UNIX)  smc_event_swing_point (UNIX))  ({t}_smc_fvg_1d_df = smc_fvg_id (string  unique code)  smc_fvg_created_time (UNIX)  smc_fvg_direction (string  bullish or bearish)  smc_fvg_interval (string)  smc_fvg_bottom(float64 USD)  smc_fvg_top(float64 USD)  smc_fvg_status (string  active or mitigated)  smc_fvg_mitigated_time(UNIX)  smc_fvg_size(float64 %)  smc_fvg_left_time (UNIX))  ({t}_smc_ob_1d_df = smc_ob_id  smc_ob_created_time(UNIX)  smc_ob_direction(string  bullish or bearish)  smc_ob_interval(string)  smc_ob_top(float64 USD)  smc_ob_bottom(float64 USD)  smc_ob_status(string  active or mitigated)  smc_ob_mitigated_time(UNIX)  smc_ob_strength(float64 %)  smc_ob_size(float64 %)  smc_ob_left_time(UNIX))  ({t}_smc_pd_1d = smc_premium_top(float64 USD)  smc_premium_bottom(float64 USD)  smc_equilibrium_top(float64 USD)  smc_equilibrium_bottom(float64 USD)  smc_discount_top(float64 USD)  smc_discount_bottom(float64 USD)  smc_trailing_top(float64 USD)  smc_trailing_bottom(float64 USD)  smc_trailing_top_time(UNIX)  smc_trailing_bottom_time(UNIX))",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "smc_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "run smc.py with 1h swing settings on the OHLCV data contained within {t}_ohlcv_1h. Results to be mapped and saved to separate dataframes with columns as defined in this row of data.  adjustable settings to be added to config.py (defaults: Swing=30)",
    "output_data_type": "multiple",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_smc_swing_1h_df  {t}_smc_event_1h_df  {t}_smc_fvg_1h_df  {t}_smc_ob_1h_df  {t}_smc_pd_1h_df",
    "df_storage_period": "as required to store all returned data",
    "df_keys": "REQUIRED COLUMNS FOR EACH SMC DATAFRAME: ({t}_smc_swing_1h_df = smc_swing_id (string  unique code)  smc_swing_confirmation_time (UNIX)  smc_swing_type (string  high or low)  smc_swing_strong (string  strong or weak)  smc_swing_interval (string)  smc_swing_pivot_time (UNIX)  smc_last_pivot_candidate_time (UNIX)  smc_last_pivot_candidate_level (float64 USD)  smc_last_pivot_candidate_type (string  high or low))  ({t}_smc_event_1h_df = smc_event_id (string  unique code)  smc_event_created (UNIX)  smc_event_type (string  BOS or CHOCH)  smc_event_direction (string  bullish or bearish)  smc_event_interval (string)  smc_event_price (float64 USD)  smc_event_break_time (UNIX)  smc_event_swing_point (UNIX))  ({t}_smc_fvg_1h_df = smc_fvg_id (string  unique code)  smc_fvg_created_time (UNIX)  smc_fvg_direction (string  bullish or bearish)  smc_fvg_interval (string)  smc_fvg_bottom(float64 USD)  smc_fvg_top(float64 USD)  smc_fvg_status (string  active or mitigated)  smc_fvg_mitigated_time(UNIX)  smc_fvg_size(float64 %)  smc_fvg_left_time (UNIX))  ({t}_smc_ob_1h_df = smc_ob_id  smc_ob_created_time(UNIX)  smc_ob_direction(string  bullish or bearish)  smc_ob_interval(string)  smc_ob_top(float64 USD)  smc_ob_bottom(float64 USD)  smc_ob_status(string  active or mitigated)  smc_ob_mitigated_time(UNIX)  smc_ob_strength(float64 %)  smc_ob_size(float64 %)  smc_ob_left_time(UNIX))  ({t}_smc_pd_1h = smc_premium_top(float64 USD)  smc_premium_bottom(float64 USD)  smc_equilibrium_top(float64 USD)  smc_equilibrium_bottom(float64 USD)  smc_discount_top(float64 USD)  smc_discount_bottom(float64 USD)  smc_trailing_top(float64 USD)  smc_trailing_bottom(float64 USD)  smc_trailing_top_time(UNIX)  smc_trailing_bottom_time(UNIX))",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "smc_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "run smc.py with 4h swing settings on the OHLCV data contained within {t}_ohlcv_4h. Results to be mapped and saved to separate dataframes with columns as defined in this row of data.  adjustable settings to be added to config.py (defaults: Swing=30)",
    "output_data_type": "multiple",
    "output_data_unit": "multiple (see df_columns)",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_smc_swing_4h_df  {t}_smc_event_4h_df  {t}_smc_fvg_4h_df  {t}_smc_ob_4h_df  {t}_smc_pd_4h_df",
    "df_storage_period": "as required to store all returned data",
    "df_keys": "REQUIRED COLUMNS FOR EACH SMC DATAFRAME: ({t}_smc_swing_4h_df = smc_swing_id (string  unique code)  smc_swing_confirmation_time (UNIX)  smc_swing_type (string  high or low)  smc_swing_strong (string  strong or weak)  smc_swing_interval (string)  smc_swing_pivot_time (UNIX)  smc_last_pivot_candidate_time (UNIX)  smc_last_pivot_candidate_level (float64 USD)  smc_last_pivot_candidate_type (string  high or low))  ({t}_smc_event_4h_df = smc_event_id (string  unique code)  smc_event_created (UNIX)  smc_event_type (string  BOS or CHOCH)  smc_event_direction (string  bullish or bearish)  smc_event_interval (string)  smc_event_price (float64 USD)  smc_event_break_time (UNIX)  smc_event_swing_point (UNIX))  ({t}_smc_fvg_4h_df = smc_fvg_id (string  unique code)  smc_fvg_created_time (UNIX)  smc_fvg_direction (string  bullish or bearish)  smc_fvg_interval (string)  smc_fvg_bottom(float64 USD)  smc_fvg_top(float64 USD)  smc_fvg_status (string  active or mitigated)  smc_fvg_mitigated_time(UNIX)  smc_fvg_size(float64 %)  smc_fvg_left_time (UNIX))  ({t}_smc_ob_4h_df = smc_ob_id  smc_ob_created_time(UNIX)  smc_ob_direction(string  bullish or bearish)  smc_ob_interval(string)  smc_ob_top(float64 USD)  smc_ob_bottom(float64 USD)  smc_ob_status(string  active or mitigated)  smc_ob_mitigated_time(UNIX)  smc_ob_strength(float64 %)  smc_ob_size(float64 %)  smc_ob_left_time(UNIX))  ({t}_smc_pd_4h = smc_premium_top(float64 USD)  smc_premium_bottom(float64 USD)  smc_equilibrium_top(float64 USD)  smc_equilibrium_bottom(float64 USD)  smc_discount_top(float64 USD)  smc_discount_bottom(float64 USD)  smc_trailing_top(float64 USD)  smc_trailing_bottom(float64 USD)  smc_trailing_top_time(UNIX)  smc_trailing_bottom_time(UNIX))",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "social_dom_zscore_24",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_social_dominance_total_15m_df",
    "transform": "(lambda s: (s - s.rolling(window=96).mean()) / (s.rolling(window=96).std() + 1e-9))({t}_social_dominance_total_15m_df['social_dominance_total_15m'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "social_dom_zscore_7d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_social_dominance_total_1d_df",
    "transform": "({t}_social_dominance_total_1d_df[-1] - mean({t}_social_dominance_total_1d_df[-7:])) / std({t}_social_dominance_total_1d_df[-7:])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "social_dominance_total_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Social Dominance Total (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'social_dominance_total_15m' df column. All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_social_dominance_total_15m_df",
    "df_storage_period": 97,
    "df_keys": "timestamp  social_dominance_total_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "social_dominance_total_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:1d Social Dominacne Total (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment)",
    "transform": "parse 'value' to 'social_dominance_total_1d' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_social_dominance_total_1d_df",
    "df_storage_period": 7,
    "df_keys": "timestamp  social_dominance_total_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "social_momentum_divergence_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_social_dominance_total_15m_df {t}_sentiment_weighted_total_15m_df {t}_ohlcv_15m_df",
    "transform": "social_dom = {t}_social_dominance_total_15m_df['social_dominance']; sentiment = {t}_sentiment_weighted_total_15m_df['sentiment_weighted']; price = {t}_ohlcv_15m_df['close']; social_momentum = social_dom.pct_change(20); sentiment_momentum = sentiment.pct_change(20); price_momentum = price.pct_change(20); divergence = (social_momentum - sentiment_momentum) * np.sign(price_momentum); divergence_strength = divergence * (abs(social_momentum).rolling(20).rank(pct=True)); divergence_strength",
    "output_data_type": "float64",
    "output_data_unit": "divergence_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "spot_perp_basis_pct_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_perp_close_1h_df {t}_ohlcv_1h_df",
    "transform": "(100 * ({t}_perp_close_1h_df['perpClose_1h'].iloc[-1] - {t}_ohlcv_1h_df['close'].iloc[-1])) / {t}_ohlcv_1h_df['close'].iloc[-1]",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "spx_close_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get ^GSPC data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse 'close' to 'spx_close_15m' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "spx_close_15m_df",
    "df_storage_period": 70,
    "df_keys": "timestamp  spx_close_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "spx_close_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get ^GSPC data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse 'close' to 'spx_close_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "spx_close_1d_df",
    "df_storage_period": 70,
    "df_keys": "timestamp  spx_close_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "spx_ema_divergence_21d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": false,
    "transform_data_source": "spx_close_1d_df spx_ema21_1d_df",
    "transform": "(100 * (spx_close_1d_df['spx_close_1d'].iloc[-21:] - spx_ema21_1d_df['ema_indicator'].iloc[-21:]) / spx_ema21_1d_df['ema_indicator'].iloc[-21:]).mean()",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "spx_ema21_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "spx_close_1d_df",
    "transform": "ta.trend.EMAIndicator(close  window=21).ema_indicator() adjustable settings to be added to config.py (defaults: Period=21)",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "spx_ema21_1d_df",
    "df_storage_period": 21,
    "df_keys": "timestamp  ema_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "spx_return_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "spx_close_1d_df",
    "transform": "np.log1p(spx_close_1d_df['spx_close_1d'].pct_change(periods=1).iloc[-1])",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "target_prediction",
    "live_cadence": "training only",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "Historical stored 15m OHLCV data",
    "transform": "For each source candle, compute the first-touch times for the six  barriers (located in {t}_barrier_strong_bull_df, {t}_barrier_bull_df, {t}_barrier_bull_invalid_df, {t}_barrier_strong_bear_df, {t}_barrier_bear_df, {t}_barrier_bear_invalid_df) within the next 32 bars. Then, apply the nested conditional logic to assign the final label to a new column named  target_prediciton. Final Target Calculation: target_prediciton = 2 if time_to_strong_bull < time_to_bull_invalid else (1 if time_to_bull < time_to_strong_bull and time_to_bull < time_to_bull_invalid else (-2 if time_to_strong_bear < time_to_bear_invalid else (-1 if time_to_bear < time_to_strong_bear and time_to_bear < time_to_bear_invalid else 0)))",
    "output_data_type": "int32",
    "output_data_unit": "category target value",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": true,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "ERROR"
  },
  {
    "operation": "time_to_target_decay_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "bars_remaining = 16; current_momentum = abs({t}_ohlcv_15m_df['close'].pct_change(4).iloc[-1]); required_momentum_per_bar = 0.02 / (bars_remaining; + 1e-9) momentum_adequacy = current_momentum / (required_momentum_per_bar + 1e-9); decay_factor = np.exp(-0.1 * (16 - bars_remaining)); time_decay_score = momentum_adequacy * decay_factor",
    "output_data_type": "float64",
    "output_data_unit": "decay_score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "timestamp",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "not applicable",
    "transform": "no transform",
    "output_data_type": "int64",
    "output_data_unit": "UNIX",
    "is_categorical_feature": null,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_ratio_zscore_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['close'] + 1e-9) - ({t}_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_ratio_zscore_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['close'] + 1e-9) - ({t}_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_ratio_zscore_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "({t}_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['close'] + 1e-9) - ({t}_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_ratio_zscore_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['close'] + 1e-9) - ({t}_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['volume'] * {t}_ohlcv_15m_df['close']) / (btc_ohlcv_15m_df['volume'] * btc_ohlcv_15m_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['volume'] * {t}_ohlcv_1d_df['close']) / (btc_ohlcv_1d_df['volume'] * btc_ohlcv_1d_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "({t}_ohlcv_1h_df['volume'] * {t}_ohlcv_1h_df['close']) / (btc_ohlcv_1h_df['volume'] * btc_ohlcv_1h_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['volume'] * {t}_ohlcv_4h_df['close']) / (btc_ohlcv_4h_df['volume'] * btc_ohlcv_4h_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_sma12_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['volume'] * {t}_ohlcv_4h_df['close'] / (btc_ohlcv_4h_df['volume'] * btc_ohlcv_4h_df['close'])).rolling(window=12).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_sma20_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['volume'] * {t}_ohlcv_15m_df['close'] / (btc_ohlcv_15m_df['volume'] * btc_ohlcv_15m_df['close'])).rolling(window=20).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_sma24_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "({t}_ohlcv_1h_df['volume'] * {t}_ohlcv_1h_df['close'] / (btc_ohlcv_1h_df['volume'] * btc_ohlcv_1h_df['close'])).rolling(window=24).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_dollar_volume_sma7_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['volume'] * {t}_ohlcv_1d_df['close'] / (btc_ohlcv_1d_df['volume'] * btc_ohlcv_1d_df['close'])).rolling(window=7).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_momentum_pct_1p_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "{t}_ohlcv_1d_df['close'].pct_change(periods=1) - btc_ohlcv_1d_df['close'].pct_change(periods=1)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_momentum_pct_3p_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "{t}_ohlcv_15m_df['close'].pct_change(periods=3) - btc_ohlcv_15m_df['close'].pct_change(periods=3)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_momentum_pct_4p_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "{t}_ohlcv_4h_df['close'].pct_change(periods=4) - btc_ohlcv_4h_df['close'].pct_change(periods=4)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_momentum_pct_6p_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "{t}_ohlcv_1h_df['close'].pct_change(periods=6) - btc_ohlcv_1h_df['close'].pct_change(periods=6)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_volatility_12p_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df btc_ohlcv_4h_df",
    "transform": "{t}_ohlcv_4h_df['close'].pct_change().rolling(window=12).std() / btc_ohlcv_4h_df['close'].pct_change().rolling(window=12).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_volatility_20p_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df btc_ohlcv_15m_df",
    "transform": "{t}_ohlcv_15m_df['close'].pct_change().rolling(window=20).std() / btc_ohlcv_15m['close'].pct_change().rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_volatility_24p_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df btc_ohlcv_1h_df",
    "transform": "{t}_ohlcv_1h_df['close'].pct_change().rolling(window=24).std() / btc_ohlcv_1h_df['close'].pct_change().rolling(window=24).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_btc_relative_volatility_7p_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df btc_ohlcv_1d_df",
    "transform": "{t}_ohlcv_1d_df['close'].pct_change().rolling(window=7).std() / btc_ohlcv_1d_df['close'].pct_change().rolling(window=7).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_ratio_zscore_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df eth_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['close'] / (eth_ohlcv_15m_df['close'] + 1e-9) - ({t}_ohlcv_15m_df['close'] / (eth_ohlcv_15m_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_15m_df['close'] / (eth_ohlcv_15m_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_ratio_zscore_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df eth_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['close'] / (eth_ohlcv_1d_df['close'] + 1e-9) - ({t}_ohlcv_1d_df['close'] / (eth_ohlcv_1d_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_1d_df['close'] / (eth_ohlcv_1d_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_ratio_zscore_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df eth_ohlcv_1h_df",
    "transform": "({t}_ohlcv_1h_df['close'] / (eth_ohlcv_1h_df['close'] + 1e-9) - ({t}_ohlcv_1h_df['close'] / (eth_ohlcv_1h_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_1h_df['close'] / (eth_ohlcv_1h_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_ratio_zscore_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df eth_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['close'] / (eth_ohlcv_4h_df['close'] + 1e-9) - ({t}_ohlcv_4h_df['close'] / (eth_ohlcv_4h_df['close'] + 1e-9)).rolling(window=20).mean()) / ({t}_ohlcv_4h_df['close'] / (eth_ohlcv_4h_df['close'] + 1e-9)).rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df eth_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['volume'] * {t}_ohlcv_15m_df['close']) / (eth_ohlcv_15m_df['volume'] * eth_ohlcv_15m_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df eth_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['volume'] * {t}_ohlcv_1d_df['close']) / (eth_ohlcv_1d_df['volume'] * eth_ohlcv_1d_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df eth_ohlcv_1h_df",
    "transform": "({t}_ohlcv_1h_df['volume'] * {t}_ohlcv_1h_df['close']) / (eth_ohlcv_1h_df['volume'] * eth_ohlcv_1h_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df eth_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['volume'] * {t}_ohlcv_4h_df['close']) / (eth_ohlcv_4h_df['volume'] * eth_ohlcv_4h_df['close'])",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_sma12_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df eth_ohlcv_4h_df",
    "transform": "({t}_ohlcv_4h_df['volume'] * {t}_ohlcv_4h_df['close'] / (eth_ohlcv_4h_df['volume'] * eth_ohlcv_4h_df['close'])).rolling(window=12).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_sma20_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df eth_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['volume'] * {t}_ohlcv_15m_df['close'] / (eth_ohlcv_15m_df['volume'] * eth_ohlcv_15m_df['close'])).rolling(window=20).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_sma24_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df eth_ohlcv_1h_df",
    "transform": "({t}_ohlcv_1h_df['volume'] * {t}_ohlcv_1h_df['close'] / (eth_ohlcv_1h_df['volume'] * eth_ohlcv_1h_df['close'])).rolling(window=24).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_dollar_volume_sma7_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df eth_ohlcv_1d_df",
    "transform": "({t}_ohlcv_1d_df['volume'] * {t}_ohlcv_1d_df['close'] / (eth_ohlcv_1d_df['volume'] * eth_ohlcv_1d_df['close'])).rolling(window=7).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_momentum_pct_1p_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df eth_ohlcv_1d_df",
    "transform": "{t}_ohlcv_1d_df['close'].pct_change(periods=1) - eth_ohlcv_1d_df['close'].pct_change(periods=1)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_momentum_pct_3p_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df eth_ohlcv_15m_df",
    "transform": "{t}_ohlcv_15m_df['close'].pct_change(periods=3) - eth_ohlcv_15m_df['close'].pct_change(periods=3)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_momentum_pct_4p_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df eth_ohlcv_4h_df",
    "transform": "{t}_ohlcv_4h_df['close'].pct_change(periods=4) - eth_ohlcv_4h_df['close'].pct_change(periods=4)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_momentum_pct_6p_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df eth_ohlcv_1h_df",
    "transform": "{t}_ohlcv_1h_df['close'].pct_change(periods=6) - eth_ohlcv_1h_df['close'].pct_change(periods=6)",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_volatility_12p_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df eth_ohlcv_4h_df",
    "transform": "{t}_ohlcv_4h_df['close'].pct_change().rolling(window=12).std() / eth_ohlcv_4h_df['close'].pct_change().rolling(window=12).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_volatility_20p_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df eth_ohlcv_15m_df",
    "transform": "{t}_ohlcv_15m_df['close'].pct_change().rolling(window=20).std() / eth_ohlcv_15m['close'].pct_change().rolling(window=20).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_volatility_24p_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df eth_ohlcv_1h_df",
    "transform": "{t}_ohlcv_1h_df['close'].pct_change().rolling(window=24).std() / eth_ohlcv_1h_df['close'].pct_change().rolling(window=24).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_eth_relative_volatility_7p_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df eth_ohlcv_1d_df",
    "transform": "{t}_ohlcv_1d_df['close'].pct_change().rolling(window=7).std() / eth_ohlcv_1d_df['close'].pct_change().rolling(window=7).std()",
    "output_data_type": "float64",
    "output_data_unit": "dimenisonless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "token_id",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "token_id to be captured and passed in each row of data",
    "transform": "no transform - token_id in the format 'BTC'  this id is the  value of {t} where used throughout this document in dataframes",
    "output_data_type": "string",
    "output_data_unit": "token_id",
    "is_categorical_feature": true,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "total_gas_used_15m",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:15m Total Gas Used (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'total_gas_used_15m' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "gas units",
    "is_categorical_feature": false,
    "df_variable_id": "total_gas_used_15m_df",
    "df_storage_period": 96,
    "df_keys": "timestamp  total_gas_used_15m",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "total_market_cap_close_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "Historical and Live:1d Total Market Cap  from Global Metrics Quotes Historical (Refer to Unicorn_Wealth_API_Reference Guide: 3.0 CoinMarketCap) ",
    "transform": "parse 'total_market_cap' to 'total_marklet_cap_1d' df column.  All raw incoming data must have df.iloc[:-1] or similar applied to ensure we do not transform or calculate incomplete data (This only applies to ingestion of raw data)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "total_mcap_close_1d_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  total_market_cap_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "transaction_volume_usd_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:1d Transaction Volume USD (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment)",
    "transform": "parse 'value' to 'transaction_volume_usd_1d' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_transaction_volume_usd_1d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  transaction_volume_usd_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "trend_strength_15m",
    "live_cadence": "15m",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_ema_fast_15m_df {t}_ema_slow_15m_df",
    "transform": "abs({t}_ema_fast_15m_df['ema_indicator'] - {t}_ema_slow_15m_df['ema_indicator']) / {t}_ohlcv_15m_df['close'] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_trend_strength_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp trend_strength",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "trend_strength_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df {t}_ema_fast_1d_df {t}_ema_slow_1d_df",
    "transform": "abs({t}_ema_fast_1d_df['ema_indicator'] - {t}_ema_slow_1d_df['ema_indicator']) / {t}_ohlcv_1d_df['close'] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "trend_strength_1h",
    "live_cadence": "1h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df {t}_ema_fast_1h_df {t}_ema_slow_1h_df",
    "transform": "abs({t}_ema_fast_1h_df['ema_indicator'] - {t}_ema_slow_1h_df['ema_indicator']) / {t}_ohlcv_1h_df['close'] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "trend_strength_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df {t}_ema_fast_4h_df {t}_ema_slow_4h_df",
    "transform": "abs({t}_ema_fast_4h_df['ema_indicator'] - {t}_ema_slow_4h_df['ema_indicator']) / {t}_ohlcv_4h_df['close'] * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "upper_wick_pct_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "({t}_ohlcv_15m_df['high'] - np.maximum({t}_ohlcv_15m_df['open']  {t}_ohlcv_15m_df['close'])) / ({t}_ohlcv_15m_df['high'] - {t}_ohlcv_15m_df['low'] + 1e-9)",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ust10y_yield_1d",
    "live_cadence": "1d",
    "step_order": 1,
    "calculate_per_token": false,
    "transform_data_source": "get ^TNX data using yfinance python module  use tick.fast_info[\"lastPrice\"] or similar so a result is 'always' returned",
    "transform": "parse 'close' to 'ust10y_yield_1d' df column",
    "output_data_type": "float64",
    "output_data_unit": "index points",
    "is_categorical_feature": false,
    "df_variable_id": "ust10y_yield_1d_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  ust10y_yield_1d",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "ust10y_yield_zscore_30d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": false,
    "transform_data_source": "ust10y_yield_1d_df",
    "transform": "(lambda s: (s - s.rolling(window=30).mean()) / (s.rolling(window=30).std() + 1e-9))(ust10y_yield_1d_df['ust10y_yield_1d'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "velocity_zscore_long",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda v: (v - v.rolling(window=96).mean()) / (v.rolling(window=96).std() + 1e-9))({t}_ohlcv_15m_df['close'].pct_change(periods=1))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "velocity_zscore_medium",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda v: (v - v.rolling(window=48).mean()) / (v.rolling(window=48).std() + 1e-9))({t}_ohlcv_15m_df['close'].pct_change(periods=1))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "velocity_zscore_short",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda v: (v - v.rolling(window=12).mean()) / (v.rolling(window=12).std() + 1e-9))({t}_ohlcv_15m_df['close'].pct_change(periods=1))",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vol_sma_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "ta.trend.SMAIndicator(volume  window=60).sma_indicator() adjustable settings to be added to config.py (defaults: Period=60)",
    "output_data_type": "float64",
    "output_data_unit": "volume units",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_vol_sma_15m_df",
    "df_storage_period": 2880,
    "df_keys": "timestamp  sma_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vol_sma_1h",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.trend.SMAIndicator(volume  window=60).sma_indicator() adjustable settings to be added to config.py (defaults: Period=60)",
    "output_data_type": "float64",
    "output_data_unit": "volume units",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_vol_sma_1h_df",
    "df_storage_period": 1440,
    "df_keys": "timestamp  sma_indicator",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_adjusted_macd_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_macd_15m_df {t}_atr_15m_df {t}_ohlcv_15m_df",
    "transform": "macd = {t}_macd_15m_df['macd']; macd_signal = {t}_macd_15m_df['macd_signal']; volatility = {t}_atr_15m_df['average_true_range'] / {t}_ohlcv_15m_df['close']; vol_adjustment = 1 / (volatility.rolling(20).rank(pct=True) + 1e-9); adjusted_macd = (macd - macd_signal) * vol_adjustment; macd_momentum = adjusted_macd.rolling(20).mean() * (abs(adjusted_macd).rolling(20).rank(pct=True)); volatility_macd = macd_momentum.rolling(20).rank(pct=True); volatility_macd",
    "output_data_type": "float64",
    "output_data_unit": "vol_macd_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_clustering_garch_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_atr_15m_df",
    "transform": "returns = {t}_ohlcv_15m_df['close'].pct_change(); atr = {t}_atr_15m_df['average_true_range']; squared_returns = returns**2; vol_persistence = squared_returns.rolling(20).corr(squared_returns.shift(1)); garch_proxy = vol_persistence * (atr.rolling(20).std() / (atr.rolling(20).mean() + 1e-9)); volatility_clustering = garch_proxy * (squared_returns.rolling(20).rank(pct=True)); volatility_clustering",
    "output_data_type": "float64",
    "output_data_unit": "garch_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_regime_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df {t}_ema_fast_1d_df {t}_ema_slow_1d_df",
    "transform": "envelope_width = abs({t}_ema_fast_1d_df['ema_indicator'] - {t}_ema_slow_1d_df['ema_indicator']) / {t}_ohlcv_1d_df['close'] * 100; envelope_width / (envelope_width.rolling + 1e-9)(20).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_regime_4h",
    "live_cadence": "4h",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df {t}_ema_fast_4h_df {t}_ema_slow_4h_df",
    "transform": "envelope_width = abs({t}_ema_fast_4h_df['ema_indicator'] - {t}_ema_slow_4h_df['ema_indicator']) / {t}_ohlcv_4h_df['close'] * 100; envelope_width / (envelope_width.rolling + 1e-9)(20).mean()",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless ratio",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_volatility_regime_4h_df",
    "df_storage_period": 1,
    "df_keys": "timestamp volatility_regime",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_target_probability_2pct_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "atr_current = {t}_ohlcv_15m_df['high'].rolling(14).max() - {t}_ohlcv_15m_df['low'].rolling(14).min(); historical_moves = (({t}_ohlcv_15m_df['close'].shift(-16) / {t}_ohlcv_15m_df['close'].shift(-32) - 1).abs() >= 0.02).shift(32); success_rate = historical_moves.rolling(100).mean(); np.where(atr_current.iloc[-1] > atr_current.rolling(50).quantile(0.7).iloc[-1], success_rate.iloc[-1] * 1.2, success_rate.iloc[-1] * 0.8)",
    "output_data_type": "float64",
    "output_data_unit": "probability",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_term_structure_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_15m_df {t}_atr_1h_df {t}_atr_4h_df {t}_atr_1d_df",
    "transform": "vol_15m = {t}_atr_15m_df['average_true_range'] / {t}_ohlcv_15m_df['close']; vol_1h = {t}_atr_1h_df['average_true_range'].reindex({t}_atr_15m_df.index, method='ffill') / {t}_ohlcv_15m_df['close']; vol_4h = {t}_atr_4h_df['average_true_range'].reindex({t}_atr_15m_df.index, method='ffill') / {t}_ohlcv_15m_df['close']; vol_1d = {t}_atr_1d_df['average_true_range'].reindex({t}_atr_15m_df.index, method='ffill') / {t}_ohlcv_15m_df['close']; term_structure = (vol_1d - vol_15m) / (vol_15m + 1e-9); structure_slope = (vol_4h - vol_1h) / (vol_1h + 1e-9); volatility_term = term_structure * structure_slope * (vol_15m.rolling(20).rank(pct=True)); volatility_term",
    "output_data_type": "float64",
    "output_data_unit": "term_structure_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_time_decay_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "current_vol = {t}_ohlcv_15m_df['close'].pct_change().rolling(16).std().iloc[-1]; required_vol_for_target = 0.02 / (2; + 1e-9) time_factor = 1 - (0 / 16); vol_time_score = (current_vol / (required_vol_for_target + 1e-9)) * time_factor",
    "output_data_type": "float64",
    "output_data_unit": "vol_time_score",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volatility_trend_regime_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_atr_normalized_15m_df, {t}_trend_strength_15m_df",
    "transform": "{t}_atr_normalized_15m_df['atr_normalized'] * {t}_trend_strength_15m_df['trend_strength']",
    "output_data_type": "float64",
    "output_data_unit": "regime_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volume_breakout_strength_4h",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "volume_current = {t}_ohlcv_4h_df['volume'].iloc[-1]; volume_avg = {t}_ohlcv_4h_df['volume'].rolling(20).mean().iloc[-1]; price_change = {t}_ohlcv_4h_df['close'].pct_change().iloc[-1]; breakout_strength = (volume_current / (volume_avg + 1e-9)) * abs(price_change) * 100",
    "output_data_type": "float64",
    "output_data_unit": "strength_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volume_momentum_confirmation_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_volume_zscore_20_15m_df, {t}_momentum_confluence_15m_df",
    "transform": "{t}_volume_zscore_20_15m_df['volume_zscore_20'] * {t}_momentum_confluence_15m_df['momentum_confluence']",
    "output_data_type": "float64",
    "output_data_unit": "confirmation_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": true,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volume_profile_anomaly_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_vwap_1d_df",
    "transform": "price = {t}_ohlcv_15m_df['close']; volume = {t}_ohlcv_15m_df['volume']; vwap = {t}_vwap_1d_df['volume_weighted_average_price'].reindex({t}_ohlcv_15m_df.index, method='ffill'); price_distance = abs(price - vwap) / vwap; volume_intensity = volume / volume.rolling(96).mean(); anomaly_score = price_distance * volume_intensity * (volume.rolling(20).rank(pct=True)); profile_anomaly = anomaly_score.rolling(20).rank(pct=True); profile_anomaly",
    "output_data_type": "float64",
    "output_data_unit": "anomaly_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volume_weighted_sentiment_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df {t}_sentiment_weighted_total_15m_df {t}_social_dominance_total_15m_df",
    "transform": "volume = {t}_ohlcv_15m_df['volume']; sentiment = {t}_sentiment_weighted_total_15m_df['sentiment_weighted']; social_dom = {t}_social_dominance_total_15m_df['social_dominance']; volume_weight = volume / volume.rolling(96).mean(); weighted_sentiment = sentiment * volume_weight; social_momentum = social_dom.pct_change(20); sentiment_momentum = weighted_sentiment.pct_change(20); volume_sentiment = (sentiment_momentum + social_momentum) / 2 * (volume.rolling(20).rank(pct=True)); volume_weighted = volume_sentiment.rolling(20).rank(pct=True); volume_weighted",
    "output_data_type": "float64",
    "output_data_unit": "sentiment_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volume_zscore_100_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda v: (v - v.rolling(window=100).mean()) / (v.rolling(window=100).std() + 1e-9))({t}_ohlcv_15m_df['volume'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "volume_zscore_20_15m",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_15m_df",
    "transform": "(lambda v: (v - v.rolling(window=20).mean()) / (v.rolling(window=20).std() + 1e-9))({t}_ohlcv_15m_df['volume'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_volume_zscore_20_15m_df",
    "df_storage_period": 1,
    "df_keys": "timestamp volume_zscore_20",
    "df_frame_store": true,
    "df_update_mode": "overwrite",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vwap_1d",
    "live_cadence": "1d",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1d_df",
    "transform": "ta.volume.VolumeWeightedAveragePrice(high  low  close  volume).volume_weighted_average_price() adjustable settings to be added to config.py (defaults: Reset Period=Yearly  Divisor=3)",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_vwap_1d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  volume_weighted_average_price",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vwap_1d_vs_vwap_30d_pct",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_vwap_1d_df {t}_vwap30d_df",
    "transform": "(({t}_vwap_1d_df['volume_weighted_average_price'].iloc[-1] - {t}_vwap30d_df['volume_weighted_average_price'].iloc[-1]) / {t}_vwap30d_df['volume_weighted_average_price'].iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vwap_30d",
    "live_cadence": "4h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_4h_df",
    "transform": "ta.volume.VolumeWeightedAveragePrice(high  low  close  volume).volume_weighted_average_price() rolling window 4h vwap over 30 days",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_vwap30d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  volume_weighted_average_price",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vwap_30d_slope_3d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_vwap_30d_df",
    "transform": "({t}_vwap_30d_df['volume_weighted_average_price'].iloc[-1] - {t}_vwap_30d_df['volume_weighted_average_price'].iloc[-4]) / (3 * {t}_vwap_30d_df['volume_weighted_average_price'].iloc[-4])",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vwap_5d",
    "live_cadence": "1h",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_ohlcv_1h_df",
    "transform": "ta.volume.VolumeWeightedAveragePrice(high  low  close  volume).volume_weighted_average_price() rolling window 1h vwap over 5 days",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_vwap_5d_df",
    "df_storage_period": 1,
    "df_keys": "timestamp  volume_weighted_average_price",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "skip",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "vwap_5d_1h_slope_1d",
    "live_cadence": "1d",
    "step_order": 3,
    "calculate_per_token": true,
    "transform_data_source": "{t}_vwap_5d_df",
    "transform": "({t}_vwap_5d_df['volume_weighted_average_price'].pct_change(periods=1).iloc[-1]) * 100",
    "output_data_type": "float64",
    "output_data_unit": "%",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "whale_cnt_zscore_30d",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_whale_transaction_count_100k_usd_to_inf_df ",
    "transform": "(lambda s: (s - s.rolling(window=30).mean()) / (s.rolling(window=30).std() + 1e-9))({t}_whale_transaction_count_100k_usd_to_inf_df['whale_transaction_count_100k_usd_to_inf'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "whale_flow_impact_15m",
    "live_cadence": "15m",
    "step_order": 4,
    "calculate_per_token": true,
    "transform_data_source": "{t}_whale_transaction_volume_1m_usd_to_inf_df {t}_whale_transaction_count_100k_usd_to_inf_df {t}_ohlcv_15m_df",
    "transform": "whale_volume = {t}_whale_transaction_volume_1m_usd_to_inf_df['whale_transaction_volume']; whale_count = {t}_whale_transaction_count_100k_usd_to_inf_df['whale_transaction_count']; market_volume = {t}_ohlcv_15m_df['volume']; whale_dominance = whale_volume / (market_volume + 1e-9); whale_intensity = whale_count.rolling(20).sum() / whale_count.rolling(100).sum(); impact_score = whale_dominance * whale_intensity * (whale_volume.rolling(20).std() / (whale_volume.rolling(20).mean() + 1e-9)); impact_score",
    "output_data_type": "float64",
    "output_data_unit": "impact_index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  },
  {
    "operation": "whale_transaction_count_100k_usd_to_inf",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Whale Transaction Count 100K USD to Inf (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment)",
    "transform": "parse 'value' to 'transaction_volume_1m_usd_to_inf' df column. All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "int32",
    "output_data_unit": "count",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_whale_transaction_count_100k_usd_to_inf_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  whale_transaction_count_100k_usd_to_inf",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "whale_transaction_volume_1m_usd_to_inf",
    "live_cadence": "15m",
    "step_order": 1,
    "calculate_per_token": true,
    "transform_data_source": "Historical and Live:15m Whale Transaction Volume 1M USD to Inf (Refer to Unicorn_Wealth_API_Reference Guide: 2.0 Santiment) ",
    "transform": "parse 'value' to 'whale_transaction_count_100k_usd_to_inf' df column.  All data requests must have the parameter includeIncompleteData=false to ensure we do not ingest and transform or calculate incomplete data",
    "output_data_type": "float64",
    "output_data_unit": "USD",
    "is_categorical_feature": false,
    "df_variable_id": "{t}_whale_transaction_volume_1m_usd_to_inf_df",
    "df_storage_period": 31,
    "df_keys": "timestamp  whale_transaction_volume_1m_usd_to_inf",
    "df_frame_store": true,
    "df_update_mode": "rolling_append",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": false,
    "ml_feature_lag_1": false,
    "ml_feature_lag_2": false,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": false,
    "is_historical_export_enabled": true,
    "is_live_append_enabled": true,
    "is_ml_target": false,
    "on_error": "retry",
    "max_retries": 3,
    "log_level": "DEBUG"
  },
  {
    "operation": "whale_vol_zscore_30d",
    "live_cadence": "15m",
    "step_order": 2,
    "calculate_per_token": true,
    "transform_data_source": "{t}_whale_transaction_volume_1m_usd_to_inf_df ",
    "transform": "(lambda s: (s - s.rolling(window=30).mean()) / (s.rolling(window=30).std() + 1e-9))({t}_whale_transaction_volume_1m_usd_to_inf_df['whale_transaction_volume_1m_usd_to_inf'])",
    "output_data_type": "float64",
    "output_data_unit": "dimensionless index",
    "is_categorical_feature": false,
    "df_variable_id": "not required",
    "df_storage_period": "not required",
    "df_keys": "not required",
    "df_frame_store": "not required",
    "df_update_mode": "not required",
    "nan_handing": "forward_fill",
    "is_ml_training_feature": true,
    "ml_feature_lag_1": true,
    "ml_feature_lag_2": true,
    "ml_feature_lag_4": false,
    "is_ml_live_feature": true,
    "is_historical_export_enabled": false,
    "is_live_append_enabled": false,
    "is_ml_target": false,
    "on_error": "halt",
    "max_retries": 1,
    "log_level": "DEBUG"
  }
]
